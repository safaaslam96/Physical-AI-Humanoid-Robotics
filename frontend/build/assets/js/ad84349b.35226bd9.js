"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[380],{8453(n,e,t){t.d(e,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(r.Provider,{value:e},n.children)}},8576(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>_});var i=t(4848),o=t(8453);const r={sidebar_position:13,title:"Chapter 13: Humanoid Robot Kinematics and Dynamics"},a="Chapter 13: Humanoid Robot Kinematics and Dynamics",s={id:"part5/chapter13",title:"Chapter 13: Humanoid Robot Kinematics and Dynamics",description:"Learning Objectives",source:"@site/docs/part5/chapter13.md",sourceDirName:"part5",slug:"/part5/chapter13",permalink:"/Physical-AI-Humanoid-Robotics/docs/part5/chapter13",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/part5/chapter13.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Chapter 13: Humanoid Robot Kinematics and Dynamics"},sidebar:"tutorialSidebar",previous:{title:"Chapter 12: Sim-to-Real Transfer Techniques",permalink:"/Physical-AI-Humanoid-Robotics/docs/part4/chapter12"},next:{title:"Chapter 14: Bipedal Locomotion and Balance Control",permalink:"/Physical-AI-Humanoid-Robotics/docs/part5/chapter14"}},l={},_=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Humanoid Kinematics",id:"introduction-to-humanoid-kinematics",level:2},{value:"Humanoid Robot Structure",id:"humanoid-robot-structure",level:3},{value:"Denavit-Hartenberg (DH) Parameters for Humanoid Robots",id:"denavit-hartenberg-dh-parameters-for-humanoid-robots",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Humanoid Dynamics",id:"humanoid-dynamics",level:2},{value:"Control Systems for Humanoid Robots",id:"control-systems-for-humanoid-robots",level:2},{value:"PID Controllers for Joint Control",id:"pid-controllers-for-joint-control",level:3},{value:"Mathematical Foundations",id:"mathematical-foundations",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Knowledge Check",id:"knowledge-check",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"chapter-13-humanoid-robot-kinematics-and-dynamics",children:"Chapter 13: Humanoid Robot Kinematics and Dynamics"}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand forward and inverse kinematics for humanoid robots"}),"\n",(0,i.jsx)(e.li,{children:"Master the mathematical foundations of humanoid dynamics"}),"\n",(0,i.jsx)(e.li,{children:"Implement kinematic solvers for complex humanoid movements"}),"\n",(0,i.jsx)(e.li,{children:"Design control systems based on dynamic models"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-humanoid-kinematics",children:"Introduction to Humanoid Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robot kinematics is the study of motion without considering the forces that cause the motion. It involves understanding the geometric relationships between the robot's links and joints, which is crucial for controlling the robot's movements and interactions with the environment."}),"\n",(0,i.jsx)(e.h3,{id:"humanoid-robot-structure",children:"Humanoid Robot Structure"}),"\n",(0,i.jsx)(e.p,{children:"A typical humanoid robot consists of:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Trunk/Torso"}),": Central body connecting upper and lower body"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Head"}),": Contains sensors (cameras, microphones, etc.)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Arms"}),": Two manipulator arms with hands"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Legs"}),": Two legs with feet for locomotion and balance"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The kinematic structure is typically a tree topology with multiple branches, making it more complex than serial manipulators."}),"\n",(0,i.jsx)(e.h3,{id:"denavit-hartenberg-dh-parameters-for-humanoid-robots",children:"Denavit-Hartenberg (DH) Parameters for Humanoid Robots"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# dh_parameters.py\nimport numpy as np\nfrom math import sin, cos, sqrt\n\nclass HumanoidDHParameters:\n    """DH parameters for a humanoid robot structure"""\n\n    def __init__(self):\n        # Define DH parameters for left arm\n        self.left_arm_dh = [\n            # [a, alpha, d, theta_offset]\n            [0, np.pi/2, 0.1, 0],      # Shoulder joint 1 (yaw)\n            [0, -np.pi/2, 0, 0],       # Shoulder joint 2 (pitch)\n            [0.15, 0, 0, -np.pi/2],    # Shoulder joint 3 (roll)\n            [0, np.pi/2, 0, 0],        # Elbow joint (pitch)\n            [0.15, 0, 0, 0],           # Wrist joint 1 (pitch)\n            [0, 0, 0.05, 0]            # Wrist joint 2 (yaw)\n        ]\n\n        # Define DH parameters for right arm\n        self.right_arm_dh = [\n            [0, np.pi/2, 0.1, 0],      # Shoulder joint 1 (yaw)\n            [0, -np.pi/2, 0, 0],       # Shoulder joint 2 (pitch)\n            [0.15, 0, 0, np.pi/2],     # Shoulder joint 3 (roll) - opposite to left\n            [0, np.pi/2, 0, 0],        # Elbow joint (pitch)\n            [0.15, 0, 0, 0],           # Wrist joint 1 (pitch)\n            [0, 0, 0.05, 0]            # Wrist joint 2 (yaw)\n        ]\n\n        # Define DH parameters for left leg\n        self.left_leg_dh = [\n            [0, -np.pi/2, 0.05, 0],    # Hip joint 1 (yaw)\n            [0, np.pi/2, 0, 0],        # Hip joint 2 (roll)\n            [0, -np.pi/2, 0.2, 0],     # Hip joint 3 (pitch)\n            [0, np.pi/2, 0, 0],        # Knee joint (pitch)\n            [0, 0, 0.2, 0],            # Ankle joint 1 (pitch)\n            [0, 0, 0.05, 0]            # Ankle joint 2 (roll)\n        ]\n\n        # Define DH parameters for right leg\n        self.right_leg_dh = [\n            [0, -np.pi/2, 0.05, 0],    # Hip joint 1 (yaw)\n            [0, np.pi/2, 0, 0],        # Hip joint 2 (roll) - opposite to left\n            [0, -np.pi/2, 0.2, 0],     # Hip joint 3 (pitch)\n            [0, np.pi/2, 0, 0],        # Knee joint (pitch)\n            [0, 0, 0.2, 0],            # Ankle joint 1 (pitch)\n            [0, 0, 0.05, 0]            # Ankle joint 2 (roll)\n        ]\n\n    def dh_transform(self, a, alpha, d, theta):\n        """Calculate DH transformation matrix"""\n        return np.array([\n            [cos(theta), -sin(theta)*cos(alpha), sin(theta)*sin(alpha), a*cos(theta)],\n            [sin(theta), cos(theta)*cos(alpha), -cos(theta)*sin(alpha), a*sin(theta)],\n            [0, sin(alpha), cos(alpha), d],\n            [0, 0, 0, 1]\n        ])\n\n    def forward_kinematics(self, joint_angles, dh_params):\n        """Calculate forward kinematics using DH parameters"""\n        T = np.eye(4)  # Identity transformation\n\n        for i, (a, alpha, d, theta_offset) in enumerate(dh_params):\n            theta = joint_angles[i] + theta_offset\n            T_i = self.dh_transform(a, alpha, d, theta)\n            T = np.dot(T, T_i)\n\n        return T\n\n    def get_end_effector_pose(self, joint_angles, dh_params):\n        """Get end effector position and orientation"""\n        T = self.forward_kinematics(joint_angles, dh_params)\n\n        position = T[:3, 3]\n        orientation = T[:3, :3]\n\n        return position, orientation\n\n# Example usage\ndef example_dh_usage():\n    dh_params = HumanoidDHParameters()\n\n    # Example joint angles for left arm (radians)\n    left_arm_angles = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n\n    # Calculate forward kinematics\n    pos, orient = dh_params.get_end_effector_pose(left_arm_angles, dh_params.left_arm_dh)\n\n    print(f"Left arm end effector position: {pos}")\n    print(f"Left arm end effector orientation:\\n{orient}")\n\nif __name__ == "__main__":\n    example_dh_usage()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Forward kinematics calculates the end-effector position and orientation given the joint angles. For humanoid robots, this involves complex multi-chain kinematics."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# forward_kinematics.py\nimport numpy as np\nfrom math import sin, cos\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass HumanoidForwardKinematics:\n    def __init__(self):\n        # Robot dimensions (example values in meters)\n        self.upper_arm_length = 0.3\n        self.lower_arm_length = 0.25\n        self.upper_leg_length = 0.4\n        self.lower_leg_length = 0.35\n        self.torso_height = 0.6\n        self.head_height = 0.2\n\n    def rotation_matrix_x(self, angle):\n        \"\"\"Rotation matrix around X axis\"\"\"\n        return np.array([\n            [1, 0, 0, 0],\n            [0, cos(angle), -sin(angle), 0],\n            [0, sin(angle), cos(angle), 0],\n            [0, 0, 0, 1]\n        ])\n\n    def rotation_matrix_y(self, angle):\n        \"\"\"Rotation matrix around Y axis\"\"\"\n        return np.array([\n            [cos(angle), 0, sin(angle), 0],\n            [0, 1, 0, 0],\n            [-sin(angle), 0, cos(angle), 0],\n            [0, 0, 0, 1]\n        ])\n\n    def rotation_matrix_z(self, angle):\n        \"\"\"Rotation matrix around Z axis\"\"\"\n        return np.array([\n            [cos(angle), -sin(angle), 0, 0],\n            [sin(angle), cos(angle), 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n\n    def translation_matrix(self, x, y, z):\n        \"\"\"Translation matrix\"\"\"\n        return np.array([\n            [1, 0, 0, x],\n            [0, 1, 0, y],\n            [0, 0, 1, z],\n            [0, 0, 0, 1]\n        ])\n\n    def left_arm_kinematics(self, joint_angles):\n        \"\"\"Calculate left arm forward kinematics\"\"\"\n        # Joint angles: [shoulder_yaw, shoulder_pitch, shoulder_roll, elbow_pitch, wrist_pitch, wrist_yaw]\n        if len(joint_angles) < 6:\n            raise ValueError(\"Need 6 joint angles for arm\")\n\n        # Start from shoulder (relative to torso)\n        T = self.translation_matrix(0.15, 0.1, self.torso_height)  # Shoulder position\n\n        # Shoulder yaw\n        T = T @ self.rotation_matrix_z(joint_angles[0])\n        # Shoulder pitch\n        T = T @ self.rotation_matrix_y(joint_angles[1])\n        # Shoulder roll\n        T = T @ self.rotation_matrix_x(joint_angles[2])\n\n        # Upper arm\n        T = T @ self.translation_matrix(0, 0, -self.upper_arm_length)\n\n        # Elbow pitch\n        T = T @ self.rotation_matrix_y(joint_angles[3])\n\n        # Lower arm\n        T = T @ self.translation_matrix(0, 0, -self.lower_arm_length)\n\n        # Wrist pitch\n        T = T @ self.rotation_matrix_y(joint_angles[4])\n        # Wrist yaw\n        T = T @ self.rotation_matrix_z(joint_angles[5])\n\n        return T\n\n    def right_arm_kinematics(self, joint_angles):\n        \"\"\"Calculate right arm forward kinematics\"\"\"\n        # Joint angles: [shoulder_yaw, shoulder_pitch, shoulder_roll, elbow_pitch, wrist_pitch, wrist_yaw]\n        if len(joint_angles) < 6:\n            raise ValueError(\"Need 6 joint angles for arm\")\n\n        # Start from shoulder (relative to torso)\n        T = self.translation_matrix(0.15, -0.1, self.torso_height)  # Shoulder position\n\n        # Shoulder yaw\n        T = T @ self.rotation_matrix_z(joint_angles[0])\n        # Shoulder pitch\n        T = T @ self.rotation_matrix_y(joint_angles[1])\n        # Shoulder roll (opposite direction to left arm)\n        T = T @ self.rotation_matrix_x(-joint_angles[2])\n\n        # Upper arm\n        T = T @ self.translation_matrix(0, 0, -self.upper_arm_length)\n\n        # Elbow pitch\n        T = T @ self.rotation_matrix_y(joint_angles[3])\n\n        # Lower arm\n        T = T @ self.translation_matrix(0, 0, -self.lower_arm_length)\n\n        # Wrist pitch\n        T = T @ self.rotation_matrix_y(joint_angles[4])\n        # Wrist yaw\n        T = T @ self.rotation_matrix_z(joint_angles[5])\n\n        return T\n\n    def left_leg_kinematics(self, joint_angles):\n        \"\"\"Calculate left leg forward kinematics\"\"\"\n        # Joint angles: [hip_yaw, hip_roll, hip_pitch, knee_pitch, ankle_pitch, ankle_roll]\n        if len(joint_angles) < 6:\n            raise ValueError(\"Need 6 joint angles for leg\")\n\n        # Start from hip (relative to torso)\n        T = self.translation_matrix(-0.05, 0.08, 0)  # Hip position\n\n        # Hip yaw\n        T = T @ self.rotation_matrix_z(joint_angles[0])\n        # Hip roll\n        T = T @ self.rotation_matrix_x(joint_angles[1])\n        # Hip pitch\n        T = T @ self.rotation_matrix_y(joint_angles[2])\n\n        # Upper leg\n        T = T @ self.translation_matrix(0, 0, -self.upper_leg_length)\n\n        # Knee pitch\n        T = T @ self.rotation_matrix_y(joint_angles[3])\n\n        # Lower leg\n        T = T @ self.translation_matrix(0, 0, -self.lower_leg_length)\n\n        # Ankle pitch\n        T = T @ self.rotation_matrix_y(joint_angles[4])\n        # Ankle roll\n        T = T @ self.rotation_matrix_x(joint_angles[5])\n\n        return T\n\n    def right_leg_kinematics(self, joint_angles):\n        \"\"\"Calculate right leg forward kinematics\"\"\"\n        # Joint angles: [hip_yaw, hip_roll, hip_pitch, knee_pitch, ankle_pitch, ankle_roll]\n        if len(joint_angles) < 6:\n            raise ValueError(\"Need 6 joint angles for leg\")\n\n        # Start from hip (relative to torso)\n        T = self.translation_matrix(-0.05, -0.08, 0)  # Hip position\n\n        # Hip yaw\n        T = T @ self.rotation_matrix_z(joint_angles[0])\n        # Hip roll (opposite to left leg)\n        T = T @ self.rotation_matrix_x(-joint_angles[1])\n        # Hip pitch\n        T = T @ self.rotation_matrix_y(joint_angles[2])\n\n        # Upper leg\n        T = T @ self.translation_matrix(0, 0, -self.upper_leg_length)\n\n        # Knee pitch\n        T = T @ self.rotation_matrix_y(joint_angles[3])\n\n        # Lower leg\n        T = T @ self.translation_matrix(0, 0, -self.lower_leg_length)\n\n        # Ankle pitch\n        T = T @ self.rotation_matrix_y(joint_angles[4])\n        # Ankle roll (opposite to left leg)\n        T = T @ self.rotation_matrix_x(-joint_angles[5])\n\n        return T\n\n    def full_body_kinematics(self, joint_angles_dict):\n        \"\"\"Calculate full body forward kinematics\"\"\"\n        # Joint angles dictionary contains angles for all limbs\n        result = {}\n\n        # Torso is at origin\n        result['torso'] = np.eye(4)\n        result['head'] = self.translation_matrix(0, 0, self.torso_height + self.head_height)\n\n        # Calculate each limb\n        if 'left_arm' in joint_angles_dict:\n            result['left_arm'] = self.left_arm_kinematics(joint_angles_dict['left_arm'])\n        if 'right_arm' in joint_angles_dict:\n            result['right_arm'] = self.right_arm_kinematics(joint_angles_dict['right_arm'])\n        if 'left_leg' in joint_angles_dict:\n            result['left_leg'] = self.left_leg_kinematics(joint_angles_dict['left_leg'])\n        if 'right_leg' in joint_angles_dict:\n            result['right_leg'] = self.right_leg_kinematics(joint_angles_dict['right_leg'])\n\n        return result\n\n    def visualize_pose(self, joint_angles_dict):\n        \"\"\"Visualize the current pose of the humanoid robot\"\"\"\n        transforms = self.full_body_kinematics(joint_angles_dict)\n\n        fig = plt.figure(figsize=(12, 8))\n        ax = fig.add_subplot(111, projection='3d')\n\n        # Plot torso\n        self.plot_limb(ax, [0, 0, 0], [0, 0, self.torso_height], 'b-', label='Torso')\n\n        # Plot head\n        if 'head' in transforms:\n            head_pos = transforms['head'][:3, 3]\n            torso_pos = [0, 0, self.torso_height]\n            self.plot_limb(ax, torso_pos, head_pos, 'b-', label='Head')\n\n        # Plot arms\n        if 'left_arm' in transforms:\n            left_arm_pos = transforms['left_arm'][:3, 3]\n            shoulder_pos = [0.15, 0.1, self.torso_height]\n            self.plot_limb(ax, shoulder_pos, left_arm_pos, 'r-', label='Left Arm')\n        if 'right_arm' in transforms:\n            right_arm_pos = transforms['right_arm'][:3, 3]\n            shoulder_pos = [0.15, -0.1, self.torso_height]\n            self.plot_limb(ax, shoulder_pos, right_arm_pos, 'g-', label='Right Arm')\n\n        # Plot legs\n        if 'left_leg' in transforms:\n            left_foot_pos = transforms['left_leg'][:3, 3]\n            hip_pos = [-0.05, 0.08, 0]\n            self.plot_limb(ax, hip_pos, left_foot_pos, 'c-', label='Left Leg')\n        if 'right_leg' in transforms:\n            right_foot_pos = transforms['right_leg'][:3, 3]\n            hip_pos = [-0.05, -0.08, 0]\n            self.plot_limb(ax, hip_pos, right_foot_pos, 'm-', label='Right Leg')\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n        ax.set_title('Humanoid Robot Pose')\n        ax.legend()\n        ax.grid(True)\n\n        plt.show()\n\n    def plot_limb(self, ax, start, end, style, label=None):\n        \"\"\"Helper function to plot a limb as a line\"\"\"\n        ax.plot([start[0], end[0]], [start[1], end[1]], [start[2], end[2]], style, label=label)\n\n# Example usage\ndef example_forward_kinematics():\n    fk = HumanoidForwardKinematics()\n\n    # Define joint angles for a pose\n    joint_angles = {\n        'left_arm': [0.1, 0.2, 0.3, 0.4, 0.5, 0.1],\n        'right_arm': [-0.1, 0.2, 0.3, 0.4, 0.5, -0.1],\n        'left_leg': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        'right_leg': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    }\n\n    # Calculate transforms\n    transforms = fk.full_body_kinematics(joint_angles)\n\n    # Print end effector positions\n    for limb, transform in transforms.items():\n        if limb != 'torso' and limb != 'head':\n            pos = transform[:3, 3]\n            print(f\"{limb} end effector position: {pos}\")\n\n    # Visualize the pose (uncomment to see plot)\n    # fk.visualize_pose(joint_angles)\n\nif __name__ == \"__main__\":\n    example_forward_kinematics()\n"})}),"\n",(0,i.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Inverse kinematics calculates the joint angles needed to achieve a desired end-effector position and orientation. This is more complex than forward kinematics and often has multiple solutions."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# inverse_kinematics.py\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom math import sin, cos, acos, atan2, sqrt\n\nclass HumanoidInverseKinematics:\n    def __init__(self):\n        # Robot dimensions\n        self.upper_arm_length = 0.3\n        self.lower_arm_length = 0.25\n        self.upper_leg_length = 0.4\n        self.lower_leg_length = 0.35\n        self.torso_height = 0.6\n\n    def jacobian(self, joint_angles, forward_func):\n        """Calculate Jacobian matrix using numerical differentiation"""\n        n = len(joint_angles)\n        end_effector_pos = forward_func(joint_angles)[:3, 3]\n\n        J = np.zeros((3, n))\n        eps = 1e-6\n\n        for i in range(n):\n            # Positive perturbation\n            angles_plus = joint_angles.copy()\n            angles_plus[i] += eps\n            pos_plus = forward_func(angles_plus)[:3, 3]\n\n            # Calculate partial derivative\n            J[:, i] = (pos_plus - end_effector_pos) / eps\n\n        return J\n\n    def left_arm_ik(self, target_pos, target_orient=None, current_angles=None):\n        """Inverse kinematics for left arm using numerical optimization"""\n        if current_angles is None:\n            current_angles = [0.0] * 6  # Default joint angles\n\n        def objective_function(angles):\n            # Calculate current end effector position\n            fk = HumanoidForwardKinematics()\n            current_transform = fk.left_arm_kinematics(angles)\n            current_pos = current_transform[:3, 3]\n\n            # Calculate distance to target\n            error = np.linalg.norm(current_pos - target_pos)\n\n            # Add joint limit penalties\n            joint_limit_penalty = 0\n            for i, angle in enumerate(angles):\n                # Example joint limits (should be customized per robot)\n                if angle < -2.0 or angle > 2.0:  # Example limits\n                    joint_limit_penalty += 100 * (abs(angle) - 2.0)**2\n\n            return error + joint_limit_penalty\n\n        # Optimize to find joint angles\n        result = minimize(objective_function, current_angles, method=\'BFGS\')\n\n        if result.success:\n            return result.x\n        else:\n            print("IK optimization failed")\n            return current_angles\n\n    def right_arm_ik(self, target_pos, target_orient=None, current_angles=None):\n        """Inverse kinematics for right arm"""\n        if current_angles is None:\n            current_angles = [0.0] * 6\n\n        def objective_function(angles):\n            fk = HumanoidForwardKinematics()\n            current_transform = fk.right_arm_kinematics(angles)\n            current_pos = current_transform[:3, 3]\n\n            error = np.linalg.norm(current_pos - target_pos)\n\n            # Add joint limit penalties\n            joint_limit_penalty = 0\n            for i, angle in enumerate(angles):\n                if angle < -2.0 or angle > 2.0:\n                    joint_limit_penalty += 100 * (abs(angle) - 2.0)**2\n\n            return error + joint_limit_penalty\n\n        result = minimize(objective_function, current_angles, method=\'BFGS\')\n\n        if result.success:\n            return result.x\n        else:\n            print("IK optimization failed")\n            return current_angles\n\n    def left_arm_analytical_ik(self, target_pos, shoulder_pos):\n        """Analytical IK for simple 2-DOF arm (shoulder + elbow)"""\n        # Simplified 2D case for demonstration\n        # target_pos: [x, y, z] in world coordinates\n        # shoulder_pos: [x, y, z] shoulder position\n\n        # Calculate relative position\n        rel_x = target_pos[0] - shoulder_pos[0]\n        rel_y = target_pos[1] - shoulder_pos[1]\n        rel_z = target_pos[2] - shoulder_pos[2]\n\n        # Project to 2D plane (simplified)\n        dist_2d = sqrt(rel_x**2 + rel_z**2)  # Working in XZ plane\n\n        # Check if target is reachable\n        total_length = self.upper_arm_length + self.lower_arm_length\n        if dist_2d > total_length:\n            print("Target out of reach")\n            return None\n\n        # Calculate elbow angle using law of cosines\n        cos_elbow = (self.upper_arm_length**2 + self.lower_arm_length**2 - dist_2d**2) / \\\n                    (2 * self.upper_arm_length * self.lower_arm_length)\n        cos_elbow = np.clip(cos_elbow, -1, 1)  # Clamp to valid range\n        elbow_angle = acos(cos_elbow)\n\n        # Calculate shoulder angles\n        shoulder_angle_1 = atan2(rel_z, rel_x)  # Shoulder yaw\n\n        # For the 2D case in XZ plane\n        cos_shoulder = (self.upper_arm_length**2 + dist_2d**2 - self.lower_arm_length**2) / \\\n                      (2 * self.upper_arm_length * dist_2d)\n        cos_shoulder = np.clip(cos_shoulder, -1, 1)\n        shoulder_angle_2 = atan2(sqrt(1 - cos_shoulder**2), cos_shoulder)\n\n        # Adjust for actual arm configuration\n        shoulder_angle_2 = shoulder_angle_2  # This is simplified\n\n        # Return joint angles (others set to 0 for simplicity)\n        joint_angles = np.array([shoulder_angle_1, shoulder_angle_2, 0, elbow_angle, 0, 0])\n\n        return joint_angles\n\n    def jacobian_ik(self, target_pos, current_angles, forward_func, max_iterations=100, tolerance=1e-4):\n        """Jacobian-based inverse kinematics"""\n        current_angles = np.array(current_angles)\n\n        for i in range(max_iterations):\n            # Calculate current position\n            current_transform = forward_func(current_angles)\n            current_pos = current_transform[:3, 3]\n\n            # Calculate error\n            error = target_pos - current_pos\n\n            if np.linalg.norm(error) < tolerance:\n                print(f"Converged after {i+1} iterations")\n                return current_angles\n\n            # Calculate Jacobian\n            J = self.jacobian(current_angles, forward_func)\n\n            # Calculate joint angle updates using pseudo-inverse\n            J_pinv = np.linalg.pinv(J)\n            delta_theta = J_pinv @ error\n\n            # Update joint angles\n            current_angles = current_angles + delta_theta * 0.1  # Step size\n\n        print(f"Did not converge after {max_iterations} iterations")\n        return current_angles\n\n    def resolve_ik_ambiguities(self, joint_angles, preferred_angles, weights=None):\n        """Resolve IK solution ambiguities by preferring certain configurations"""\n        if weights is None:\n            weights = np.ones_like(joint_angles)\n\n        # Calculate differences from preferred angles\n        differences = joint_angles - preferred_angles\n\n        # Apply weights to penalize deviations from preferred configuration\n        weighted_differences = differences * weights\n\n        return joint_angles - weighted_differences * 0.1  # Small adjustment\n\n# Example usage\ndef example_inverse_kinematics():\n    ik = HumanoidInverseKinematics()\n    fk = HumanoidForwardKinematics()\n\n    # Define a target position for the left hand\n    target_pos = np.array([0.5, 0.2, 0.4])  # x, y, z in meters\n\n    # Calculate IK\n    initial_angles = [0.1, 0.2, 0.0, 0.0, 0.0, 0.0]\n    joint_angles = ik.left_arm_ik(target_pos, current_angles=initial_angles)\n\n    if joint_angles is not None:\n        print(f"Calculated joint angles: {joint_angles}")\n\n        # Verify with forward kinematics\n        final_transform = fk.left_arm_kinematics(joint_angles)\n        final_pos = final_transform[:3, 3]\n        print(f"Final position: {final_pos}")\n        print(f"Target position: {target_pos}")\n        print(f"Position error: {np.linalg.norm(final_pos - target_pos)}")\n\n    # Example of analytical IK for simplified case\n    shoulder_pos = np.array([0.15, 0.1, 0.6])  # Shoulder position\n    simplified_target = np.array([0.4, 0.1, 0.4])\n    analytical_solution = ik.left_arm_analytical_ik(simplified_target, shoulder_pos)\n\n    if analytical_solution is not None:\n        print(f"Analytical IK solution: {analytical_solution}")\n\nif __name__ == "__main__":\n    example_inverse_kinematics()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-dynamics",children:"Humanoid Dynamics"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid dynamics involves understanding the forces and torques required to produce the desired motion. This is crucial for balance control and stable locomotion."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# humanoid_dynamics.py\nimport numpy as np\nfrom math import sin, cos\nimport matplotlib.pyplot as plt\n\nclass HumanoidDynamics:\n    def __init__(self):\n        # Robot parameters (example values)\n        self.link_masses = {\n            \'torso\': 10.0,\n            \'head\': 2.0,\n            \'upper_arm\': 1.5,\n            \'lower_arm\': 1.0,\n            \'hand\': 0.5,\n            \'upper_leg\': 3.0,\n            \'lower_leg\': 2.5,\n            \'foot\': 1.0\n        }\n\n        # Moments of inertia (simplified as spheres)\n        self.link_inertias = {\n            \'torso\': np.diag([1.0, 1.0, 1.0]),\n            \'head\': np.diag([0.1, 0.1, 0.1]),\n            \'upper_arm\': np.diag([0.1, 0.1, 0.1]),\n            \'lower_arm\': np.diag([0.05, 0.05, 0.05]),\n            \'hand\': np.diag([0.02, 0.02, 0.02]),\n            \'upper_leg\': np.diag([0.3, 0.3, 0.3]),\n            \'lower_leg\': np.diag([0.2, 0.2, 0.2]),\n            \'foot\': np.diag([0.05, 0.05, 0.05])\n        }\n\n        # Link lengths (meters)\n        self.link_lengths = {\n            \'upper_arm\': 0.3,\n            \'lower_arm\': 0.25,\n            \'upper_leg\': 0.4,\n            \'lower_leg\': 0.35,\n            \'torso\': 0.6,\n            \'head\': 0.2\n        }\n\n        # Gravity\n        self.g = 9.81  # m/s^2\n\n    def compute_lagrangian_dynamics(self, joint_angles, joint_velocities, joint_accelerations):\n        """\n        Compute inverse dynamics using Lagrangian formulation\n        This calculates required joint torques for given motion\n        """\n        # This is a simplified example - full implementation would be very complex\n        n = len(joint_angles)  # Number of joints\n\n        # Mass matrix M(q)\n        M = self.compute_mass_matrix(joint_angles)\n\n        # Coriolis and centrifugal terms C(q, q_dot)\n        C = self.compute_coriolis_matrix(joint_angles, joint_velocities)\n\n        # Gravity terms g(q)\n        G = self.compute_gravity_terms(joint_angles)\n\n        # Required joint torques: \u03c4 = M(q)*q_ddot + C(q, q_dot)*q_dot + G(q)\n        torques = M @ joint_accelerations + C @ joint_velocities + G\n\n        return torques\n\n    def compute_mass_matrix(self, joint_angles):\n        """Compute the mass matrix M(q)"""\n        # Simplified mass matrix calculation\n        # In reality, this would involve complex recursive calculations\n        n = len(joint_angles)\n        M = np.zeros((n, n))\n\n        # Diagonal elements (simplified)\n        for i in range(n):\n            # Approximate moment of inertia contribution\n            M[i, i] = 1.0  # This would be calculated based on link properties\n\n        return M\n\n    def compute_coriolis_matrix(self, joint_angles, joint_velocities):\n        """Compute Coriolis and centrifugal matrix C(q, q_dot)"""\n        n = len(joint_angles)\n        C = np.zeros((n, n))\n\n        # Simplified Coriolis terms\n        # In reality, this would involve complex velocity-dependent terms\n        for i in range(n):\n            for j in range(n):\n                # Simplified velocity coupling\n                C[i, j] = 0.1 * joint_velocities[j] if i != j else 0\n\n        return C\n\n    def compute_gravity_terms(self, joint_angles):\n        """Compute gravity terms g(q)"""\n        n = len(joint_angles)\n        G = np.zeros(n)\n\n        # Simplified gravity effects\n        for i in range(n):\n            # Gravity effect based on joint configuration\n            G[i] = 0.5 * sin(joint_angles[i])  # Simplified model\n\n        return G\n\n    def euler_lagrange_equation(self, joint_angles, joint_velocities, torques):\n        """\n        Solve forward dynamics: M(q)*q_ddot = \u03c4 - C(q, q_dot)*q_dot - G(q)\n        This calculates accelerations for given torques\n        """\n        M = self.compute_mass_matrix(joint_angles)\n        C = self.compute_coriolis_matrix(joint_angles, joint_velocities)\n        G = self.compute_gravity_terms(joint_angles)\n\n        # Solve for accelerations: q_ddot = M^(-1) * (\u03c4 - C*q_dot - G)\n        accelerations = np.linalg.solve(M, torques - C @ joint_velocities - G)\n\n        return accelerations\n\n    def compute_center_of_mass(self, joint_angles):\n        """Compute center of mass position"""\n        # Simplified CoM calculation\n        total_mass = sum(self.link_masses.values())\n\n        # This would involve complex kinematic calculations in reality\n        # For now, return a simplified estimate\n        com_x = 0.0\n        com_y = 0.0\n        com_z = self.link_lengths[\'torso\'] / 2  # Approximate CoM height\n\n        return np.array([com_x, com_y, com_z])\n\n    def compute_zero_moment_point(self, joint_angles, joint_velocities, joint_accelerations):\n        """Compute Zero Moment Point (ZMP) for balance analysis"""\n        # ZMP = [x, y] where net moment about this point is zero\n        # ZMP_x = (g * (CoM_x - ZMP_x)) / (g + CoM_z_ddot) + CoM_x_ddot / (g + CoM_z_ddot)\n        # ZMP_y = (g * (CoM_y - ZMP_y)) / (g + CoM_z_ddot) + CoM_y_ddot / (g + CoM_z_ddot)\n\n        # This would require full dynamic model and CoM calculations\n        # Simplified return\n        return np.array([0.0, 0.0])\n\n    def compute_balance_metrics(self, joint_angles, joint_velocities, joint_accelerations):\n        """Compute various balance-related metrics"""\n        # Center of Mass\n        com_pos = self.compute_center_of_mass(joint_angles)\n\n        # Zero Moment Point (simplified)\n        zmp_pos = self.compute_zero_moment_point(joint_angles, joint_velocities, joint_accelerations)\n\n        # Support polygon (simplified - just the feet positions)\n        support_polygon = self.calculate_support_polygon(joint_angles)\n\n        # Calculate distance from CoM to support polygon\n        com_in_support = self.is_com_in_support_polygon(com_pos[:2], support_polygon)\n\n        # Calculate margin of stability\n        stability_margin = self.calculate_stability_margin(com_pos[:2], support_polygon)\n\n        return {\n            \'center_of_mass\': com_pos,\n            \'zero_moment_point\': zmp_pos,\n            \'support_polygon\': support_polygon,\n            \'com_in_support\': com_in_support,\n            \'stability_margin\': stability_margin\n        }\n\n    def calculate_support_polygon(self, joint_angles):\n        """Calculate support polygon based on foot positions"""\n        # This would use forward kinematics to get foot positions\n        # Simplified return: approximate foot positions\n        left_foot = np.array([-0.1, 0.1])  # Simplified\n        right_foot = np.array([-0.1, -0.1])  # Simplified\n\n        return np.array([left_foot, right_foot])\n\n    def is_com_in_support_polygon(self, com_xy, support_polygon):\n        """Check if CoM is within support polygon"""\n        # Simplified for rectangular support\n        if len(support_polygon) >= 2:\n            min_x = min(point[0] for point in support_polygon)\n            max_x = max(point[0] for point in support_polygon)\n            min_y = min(point[1] for point in support_polygon)\n            max_y = max(point[1] for point in support_polygon)\n\n            return (min_x <= com_xy[0] <= max_x) and (min_y <= com_xy[1] <= max_y)\n\n        return False\n\n    def calculate_stability_margin(self, com_xy, support_polygon):\n        """Calculate minimum distance from CoM to support polygon edge"""\n        if len(support_polygon) < 2:\n            return 0.0\n\n        # Simplified calculation for rectangular support\n        min_x = min(point[0] for point in support_polygon)\n        max_x = max(point[0] for point in support_polygon)\n        min_y = min(point[1] for point in support_polygon)\n        max_y = max(point[1] for point in support_polygon)\n\n        # Calculate distances to each edge\n        dx1 = abs(com_xy[0] - min_x)\n        dx2 = abs(max_x - com_xy[0])\n        dy1 = abs(com_xy[1] - min_y)\n        dy2 = abs(max_y - com_xy[1])\n\n        return min(dx1, dx2, dy1, dy2)\n\n    def simulate_dynamics_step(self, joint_angles, joint_velocities, joint_torques, dt):\n        """Simulate one time step of robot dynamics"""\n        # Calculate accelerations\n        joint_accelerations = self.euler_lagrange_equation(\n            joint_angles, joint_velocities, joint_torques\n        )\n\n        # Update velocities and positions using simple integration\n        new_joint_velocities = joint_velocities + joint_accelerations * dt\n        new_joint_angles = joint_angles + new_joint_velocities * dt\n\n        return new_joint_angles, new_joint_velocities, joint_accelerations\n\n# Example usage\ndef example_dynamics():\n    dynamics = HumanoidDynamics()\n\n    # Example joint state\n    joint_angles = np.array([0.1, 0.2, 0.0, 0.0, 0.0, 0.0] * 4)  # 24 joints (simplified)\n    joint_velocities = np.array([0.0] * len(joint_angles))\n    joint_accelerations = np.array([0.0] * len(joint_angles))\n\n    # Calculate required torques for some motion\n    torques = dynamics.compute_lagrangian_dynamics(joint_angles, joint_velocities, joint_accelerations)\n\n    print(f"Required joint torques: {torques}")\n\n    # Calculate balance metrics\n    balance_metrics = dynamics.compute_balance_metrics(joint_angles, joint_velocities, joint_accelerations)\n\n    print(f"Center of Mass: {balance_metrics[\'center_of_mass\']}")\n    print(f"ZMP: {balance_metrics[\'zero_moment_point\']}")\n    print(f"Stability Margin: {balance_metrics[\'stability_margin\']}")\n    print(f"CoM in support: {balance_metrics[\'com_in_support\']}")\n\nif __name__ == "__main__":\n    example_dynamics()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"control-systems-for-humanoid-robots",children:"Control Systems for Humanoid Robots"}),"\n",(0,i.jsx)(e.h3,{id:"pid-controllers-for-joint-control",children:"PID Controllers for Joint Control"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# control_systems.py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nclass PIDController:\n    """PID controller for joint control"""\n    def __init__(self, kp, ki, kd, output_limits=(-np.inf, np.inf)):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.output_limits = output_limits\n\n        self.reset()\n\n    def reset(self):\n        """Reset the PID controller"""\n        self.previous_error = 0.0\n        self.integral = 0.0\n        self.previous_time = None\n\n    def compute(self, setpoint, measurement, dt=None):\n        """Compute control output"""\n        current_time = time.time()\n        if dt is None:\n            if self.previous_time is not None:\n                dt = current_time - self.previous_time\n            else:\n                dt = 0.01  # Default time step\n        self.previous_time = current_time\n\n        # Calculate error\n        error = setpoint - measurement\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        if dt > 0:\n            derivative = (error - self.previous_error) / dt\n        else:\n            derivative = 0\n        d_term = self.kd * derivative\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        # Apply output limits\n        output = np.clip(output, self.output_limits[0], self.output_limits[1])\n\n        # Store values for next iteration\n        self.previous_error = error\n\n        return output\n\nclass JointController:\n    """Controller for a single joint with safety limits"""\n    def __init__(self, joint_name, kp=100, ki=1, kd=10):\n        self.joint_name = joint_name\n        self.pid = PIDController(kp, ki, kd)\n        self.position_limit = (-np.pi, np.pi)  # Default limits\n        self.velocity_limit = 5.0  # rad/s\n        self.torque_limit = 100.0  # Nm\n\n    def set_position_limits(self, min_pos, max_pos):\n        """Set position limits for the joint"""\n        self.position_limit = (min_pos, max_pos)\n\n    def set_velocity_limit(self, max_vel):\n        """Set velocity limit for the joint"""\n        self.velocity_limit = max_vel\n\n    def set_torque_limit(self, max_torque):\n        """Set torque limit for the joint"""\n        self.torque_limit = max_torque\n\n    def compute_torque(self, desired_pos, current_pos, current_vel, dt=0.001):\n        """Compute required torque to reach desired position"""\n        # Check position limits\n        if not (self.position_limit[0] <= desired_pos <= self.position_limit[1]):\n            print(f"Warning: Desired position {desired_pos} outside limits {self.position_limit} for {self.joint_name}")\n\n        # Compute control effort\n        torque = self.pid.compute(desired_pos, current_pos, dt)\n\n        # Apply torque limits\n        torque = np.clip(torque, -self.torque_limit, self.torque_limit)\n\n        return torque\n\nclass HumanoidController:\n    """Controller for the entire humanoid robot"""\n    def __init__(self):\n        # Create controllers for each joint\n        self.joint_controllers = {}\n        self.create_joint_controllers()\n\n    def create_joint_controllers(self):\n        """Create PID controllers for all joints"""\n        # Define joint names\n        joint_names = [\n            \'left_hip_yaw\', \'left_hip_roll\', \'left_hip_pitch\',\n            \'left_knee\', \'left_ankle_pitch\', \'left_ankle_roll\',\n            \'right_hip_yaw\', \'right_hip_roll\', \'right_hip_pitch\',\n            \'right_knee\', \'right_ankle_pitch\', \'right_ankle_roll\',\n            \'left_shoulder_yaw\', \'left_shoulder_pitch\', \'left_shoulder_roll\',\n            \'left_elbow\', \'left_wrist_pitch\', \'left_wrist_yaw\',\n            \'right_shoulder_yaw\', \'right_shoulder_pitch\', \'right_shoulder_roll\',\n            \'right_elbow\', \'right_wrist_pitch\', \'right_wrist_yaw\'\n        ]\n\n        # Create controllers with appropriate parameters\n        for joint_name in joint_names:\n            if \'hip\' in joint_name or \'knee\' in joint_name or \'ankle\' in joint_name:\n                # Legs typically need higher torque\n                controller = JointController(joint_name, kp=200, ki=2, kd=20)\n            else:\n                # Arms can use lower torque\n                controller = JointController(joint_name, kp=100, ki=1, kd=10)\n\n            self.joint_controllers[joint_name] = controller\n\n    def compute_joint_torques(self, desired_positions, current_positions, current_velocities, dt=0.001):\n        """Compute torques for all joints"""\n        torques = {}\n\n        for joint_name in self.joint_controllers:\n            if joint_name in desired_positions and joint_name in current_positions and joint_name in current_velocities:\n                torque = self.joint_controllers[joint_name].compute_torque(\n                    desired_positions[joint_name],\n                    current_positions[joint_name],\n                    current_velocities[joint_name],\n                    dt\n                )\n                torques[joint_name] = torque\n\n        return torques\n\n    def balance_control(self, com_error, zmp_error):\n        """Balance control to maintain stability"""\n        # Simple balance control based on CoM and ZMP errors\n        # This would involve more complex algorithms in practice\n        balance_torques = {}\n\n        # Adjust ankle joints based on balance errors\n        for joint_name in self.joint_controllers:\n            if \'ankle\' in joint_name:\n                # Apply balance correction\n                balance_torque = -10 * com_error - 5 * zmp_error  # Simplified\n                balance_torques[joint_name] = balance_torque\n\n        return balance_torques\n\n# Example usage\ndef example_control_system():\n    controller = HumanoidController()\n\n    # Example desired and current positions\n    desired_positions = {name: 0.0 for name in controller.joint_controllers}\n    current_positions = {name: 0.01 for name in controller.joint_controllers}  # Small error\n    current_velocities = {name: 0.0 for name in controller.joint_controllers}\n\n    # Compute required torques\n    torques = controller.compute_joint_torques(desired_positions, current_positions, current_velocities)\n\n    print("Computed joint torques:")\n    for joint_name, torque in list(torques.items())[:6]:  # Show first 6\n        print(f"  {joint_name}: {torque:.3f} Nm")\n\n    # Example balance control\n    balance_torques = controller.balance_control(com_error=0.01, zmp_error=0.005)\n    print("\\nBalance control torques:")\n    for joint_name, torque in balance_torques.items():\n        print(f"  {joint_name}: {torque:.3f} Nm")\n\nif __name__ == "__main__":\n    import time\n    example_control_system()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"mathematical-foundations",children:"Mathematical Foundations"}),"\n",(0,i.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# mathematical_foundations.py\nimport numpy as np\nfrom math import sin, cos, sqrt\n\ndef skew_symmetric_matrix(vector):\n    """Create skew-symmetric matrix from a 3D vector"""\n    return np.array([\n        [0, -vector[2], vector[1]],\n        [vector[2], 0, -vector[0]],\n        [-vector[1], vector[0], 0]\n    ])\n\ndef rotation_matrix_from_axis_angle(axis, angle):\n    """Create rotation matrix from axis-angle representation"""\n    axis = axis / np.linalg.norm(axis)  # Normalize axis\n    K = skew_symmetric_matrix(axis)\n    I = np.eye(3)\n\n    # Rodrigues\' rotation formula\n    R = I + sin(angle) * K + (1 - cos(angle)) * K @ K\n    return R\n\ndef quaternion_to_rotation_matrix(q):\n    """Convert quaternion to rotation matrix"""\n    w, x, y, z = q\n    return np.array([\n        [1 - 2*(y**2 + z**2), 2*(x*y - w*z), 2*(x*z + w*y)],\n        [2*(x*y + w*z), 1 - 2*(x**2 + z**2), 2*(y*z - w*x)],\n        [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x**2 + y**2)]\n    ])\n\ndef rotation_matrix_to_quaternion(R):\n    """Convert rotation matrix to quaternion"""\n    trace = np.trace(R)\n\n    if trace > 0:\n        s = sqrt(trace + 1.0) * 2  # S=4*qw\n        qw = 0.25 * s\n        qx = (R[2, 1] - R[1, 2]) / s\n        qy = (R[0, 2] - R[2, 0]) / s\n        qz = (R[1, 0] - R[0, 1]) / s\n    else:\n        if R[0, 0] > R[1, 1] and R[0, 0] > R[2, 2]:\n            s = sqrt(1.0 + R[0, 0] - R[1, 1] - R[2, 2]) * 2\n            qw = (R[2, 1] - R[1, 2]) / s\n            qx = 0.25 * s\n            qy = (R[0, 1] + R[1, 0]) / s\n            qz = (R[0, 2] + R[2, 0]) / s\n        elif R[1, 1] > R[2, 2]:\n            s = sqrt(1.0 + R[1, 1] - R[0, 0] - R[2, 2]) * 2\n            qw = (R[0, 2] - R[2, 0]) / s\n            qx = (R[0, 1] + R[1, 0]) / s\n            qy = 0.25 * s\n            qz = (R[1, 2] + R[2, 1]) / s\n        else:\n            s = sqrt(1.0 + R[2, 2] - R[0, 0] - R[1, 1]) * 2\n            qw = (R[1, 0] - R[0, 1]) / s\n            qx = (R[0, 2] + R[2, 0]) / s\n            qy = (R[1, 2] + R[2, 1]) / s\n            qz = 0.25 * s\n\n    return np.array([qw, qx, qy, qz])\n\ndef transform_point(point, transform_matrix):\n    """Transform a 3D point using a 4x4 transformation matrix"""\n    # Convert to homogeneous coordinates\n    homogeneous_point = np.append(point, 1)\n    # Apply transformation\n    transformed_point = transform_matrix @ homogeneous_point\n    # Convert back to 3D\n    return transformed_point[:3]\n\ndef compose_transforms(T1, T2):\n    """Compose two transformation matrices"""\n    return T1 @ T2\n\ndef inverse_transform(transform_matrix):\n    """Calculate inverse of a transformation matrix"""\n    R = transform_matrix[:3, :3]\n    t = transform_matrix[:3, 3]\n\n    R_inv = R.T\n    t_inv = -R.T @ t\n\n    inv_transform = np.eye(4)\n    inv_transform[:3, :3] = R_inv\n    inv_transform[:3, 3] = t_inv\n\n    return inv_transform\n\n# Example usage\ndef example_mathematical_foundations():\n    print("Mathematical Foundations Examples:")\n\n    # Skew-symmetric matrix\n    v = np.array([1, 2, 3])\n    S = skew_symmetric_matrix(v)\n    print(f"Skew-symmetric matrix of {v}:")\n    print(S)\n\n    # Axis-angle rotation\n    axis = np.array([0, 0, 1])  # Z-axis\n    angle = np.pi / 4  # 45 degrees\n    R = rotation_matrix_from_axis_angle(axis, angle)\n    print(f"\\nRotation matrix for {angle:.2f} rad around {axis}:")\n    print(R)\n\n    # Quaternion operations\n    q = np.array([1, 0, 0, 0])  # Identity quaternion\n    R_from_q = quaternion_to_rotation_matrix(q)\n    print(f"\\nRotation matrix from identity quaternion:")\n    print(R_from_q)\n\n    # Point transformation\n    point = np.array([1, 0, 0])\n    T = np.eye(4)\n    T[:3, 3] = [2, 0, 0]  # Translation by 2 units in X\n    transformed_point = transform_point(point, T)\n    print(f"\\nTransforming point {point} by translation matrix:")\n    print(f"Result: {transformed_point}")\n\nif __name__ == "__main__":\n    example_mathematical_foundations()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"knowledge-check",children:"Knowledge Check"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"What are the main differences between forward and inverse kinematics for humanoid robots?"}),"\n",(0,i.jsx)(e.li,{children:"How do you calculate the center of mass for a humanoid robot?"}),"\n",(0,i.jsx)(e.li,{children:"What is the Zero Moment Point (ZMP) and why is it important for balance?"}),"\n",(0,i.jsx)(e.li,{children:"How do joint limits affect inverse kinematics solutions?"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter covered the fundamental kinematics and dynamics of humanoid robots. We explored forward and inverse kinematics using both analytical and numerical methods, examined the dynamics of multi-link systems, and discussed control systems for joint actuation. The chapter provided mathematical foundations including rotation matrices, quaternions, and transformation mathematics essential for humanoid robot control."}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(e.p,{children:"In the next chapter, we'll explore bipedal locomotion and balance control, diving into the principles of walking algorithms, stability control, and the dynamics of bipedal movement for humanoid robots."})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(m,{...n})}):m(n)}}}]);