"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[845],{1273(t,e,n){n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=n(4848),i=n(8453);const r={sidebar_position:14,title:"Chapter 14: Bipedal Locomotion and Balance Control"},s="Chapter 14: Bipedal Locomotion and Balance Control",a={id:"part5/chapter14",title:"Chapter 14: Bipedal Locomotion and Balance Control",description:"Learning Objectives",source:"@site/docs/part5/chapter14.md",sourceDirName:"part5",slug:"/part5/chapter14",permalink:"/Physical-AI-Humanoid-Robotics/docs/part5/chapter14",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/part5/chapter14.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14,title:"Chapter 14: Bipedal Locomotion and Balance Control"},sidebar:"tutorialSidebar",previous:{title:"Chapter 13: Humanoid Robot Kinematics and Dynamics",permalink:"/Physical-AI-Humanoid-Robotics/docs/part5/chapter13"},next:{title:"Chapter 15: Manipulation and Grasping",permalink:"/Physical-AI-Humanoid-Robotics/docs/part5/chapter15"}},p={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Bipedal Locomotion",id:"introduction-to-bipedal-locomotion",level:2},{value:"Fundamentals of Human Walking",id:"fundamentals-of-human-walking",level:3},{value:"Key Concepts in Bipedal Locomotion",id:"key-concepts-in-bipedal-locomotion",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"ZMP-Based Walking Pattern Generation",id:"zmp-based-walking-pattern-generation",level:3},{value:"Footstep Planning and Path Following",id:"footstep-planning-and-path-following",level:3},{value:"Balance Control Mechanisms",id:"balance-control-mechanisms",level:2},{value:"Center of Mass Control",id:"center-of-mass-control",level:3},{value:"Stability Control Algorithms",id:"stability-control-algorithms",level:2},{value:"Capture Point and Divergent Component of Motion",id:"capture-point-and-divergent-component-of-motion",level:3},{value:"Walking Pattern Implementation",id:"walking-pattern-implementation",level:2},{value:"Pattern Generators and Interpolation",id:"pattern-generators-and-interpolation",level:3},{value:"Knowledge Check",id:"knowledge-check",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function _(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"chapter-14-bipedal-locomotion-and-balance-control",children:"Chapter 14: Bipedal Locomotion and Balance Control"}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the principles of bipedal locomotion in humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Implement balance control mechanisms for stable walking"}),"\n",(0,o.jsx)(e.li,{children:"Master stability control algorithms for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Design walking patterns and gait generation systems"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-bipedal-locomotion",children:"Introduction to Bipedal Locomotion"}),"\n",(0,o.jsx)(e.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control algorithms to maintain balance while walking. Unlike wheeled robots, bipedal robots must constantly manage their center of mass and adjust their posture to avoid falling."}),"\n",(0,o.jsx)(e.h3,{id:"fundamentals-of-human-walking",children:"Fundamentals of Human Walking"}),"\n",(0,o.jsx)(e.p,{children:"Human walking involves a complex interplay of biomechanics, neural control, and environmental adaptation. For humanoid robots, we must replicate these principles through mathematical models and control systems."}),"\n",(0,o.jsx)(e.h3,{id:"key-concepts-in-bipedal-locomotion",children:"Key Concepts in Bipedal Locomotion"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass (CoM)"}),": The point where the robot's mass is concentrated"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": The point where the net moment of the ground reaction force is zero"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Support Polygon"}),": The area defined by the feet in contact with the ground"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stance Phase"}),": When a foot is in contact with the ground"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Swing Phase"}),": When a foot is moving through the air"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Double Support Phase"}),": When both feet are in contact with the ground"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,o.jsx)(e.h3,{id:"zmp-based-walking-pattern-generation",children:"ZMP-Based Walking Pattern Generation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# zmp_walking.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom math import sinh, cosh, sqrt\n\nclass ZMPWalkingPatternGenerator:\n    def __init__(self, robot_height=0.8, step_length=0.3, step_width=0.2, step_height=0.05):\n        self.robot_height = robot_height  # Height of CoM from ground\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_height = step_height\n        self.omega = sqrt(9.81 / robot_height)  # Natural frequency\n        self.g = 9.81  # Gravity\n\n    def generate_footsteps(self, num_steps, start_pos=(0, 0), start_yaw=0):\n        \"\"\"Generate footstep positions for walking\"\"\"\n        footsteps = []\n\n        current_x, current_y = start_pos\n        current_yaw = start_yaw\n\n        for i in range(num_steps):\n            # Determine which foot to step with (alternating)\n            foot = 'left' if i % 2 == 0 else 'right'\n\n            # Calculate step position\n            if foot == 'left':\n                step_x = current_x + self.step_length * cos(current_yaw)\n                step_y = current_y + self.step_width * sin(current_yaw)\n                step_yaw = current_yaw\n            else:\n                step_x = current_x + self.step_length * cos(current_yaw)\n                step_y = current_y - self.step_width * sin(current_yaw)\n                step_yaw = current_yaw\n\n            footsteps.append({\n                'step': i + 1,\n                'foot': foot,\n                'position': (step_x, step_y),\n                'yaw': step_yaw\n            })\n\n            # Update current position for next step\n            current_x = step_x\n            current_y = step_y\n\n        return footsteps\n\n    def calculate_zmp_trajectory(self, footsteps, dt=0.01, double_support_ratio=0.1):\n        \"\"\"Calculate ZMP trajectory for the footsteps\"\"\"\n        # Calculate total walking time\n        total_time = len(footsteps) * 1.0  # 1 second per step\n\n        # Time vector\n        t = np.arange(0, total_time, dt)\n        zmp_x = np.zeros_like(t)\n        zmp_y = np.zeros_like(t)\n\n        # Generate ZMP trajectory following the footsteps\n        for i, step in enumerate(footsteps):\n            step_start = i\n            step_end = i + 1\n\n            # Support phase: ZMP follows the supporting foot\n            support_start_idx = int(step_start / dt)\n            support_end_idx = int((step_start + 1 - double_support_ratio) / dt)\n\n            if support_end_idx >= len(t):\n                support_end_idx = len(t) - 1\n\n            # Set ZMP to foot position during support\n            foot_pos = step['position']\n            zmp_x[support_start_idx:support_end_idx] = foot_pos[0]\n            zmp_y[support_start_idx:support_end_idx] = foot_pos[1]\n\n            # Double support phase transition\n            if i < len(footsteps) - 1:  # Not the last step\n                next_foot_pos = footsteps[i + 1]['position']\n                transition_start_idx = support_end_idx\n                transition_end_idx = int((step_start + 1) / dt)\n\n                if transition_end_idx >= len(t):\n                    transition_end_idx = len(t) - 1\n\n                # Linear interpolation between feet\n                transition_duration = transition_end_idx - transition_start_idx\n                if transition_duration > 0:\n                    for j in range(transition_duration):\n                        alpha = j / transition_duration\n                        zmp_x[transition_start_idx + j] = (1 - alpha) * foot_pos[0] + alpha * next_foot_pos[0]\n                        zmp_y[transition_start_idx + j] = (1 - alpha) * foot_pos[1] + alpha * next_foot_pos[1]\n\n        return t, zmp_x, zmp_y\n\n    def generate_com_trajectory(self, zmp_trajectory, dt=0.01):\n        \"\"\"Generate CoM trajectory from ZMP using inverted pendulum model\"\"\"\n        t, zmp_x, zmp_y = zmp_trajectory\n\n        # Initialize CoM trajectory\n        com_x = np.zeros_like(zmp_x)\n        com_y = np.zeros_like(zmp_y)\n\n        # Initial conditions (start at CoM position above first foot)\n        if len(zmp_x) > 0:\n            com_x[0] = zmp_x[0]  # Start at ZMP\n            com_y[0] = zmp_y[0]\n\n        # Velocity and acceleration\n        com_dx = np.zeros_like(zmp_x)\n        com_dy = np.zeros_like(zmp_y)\n\n        # Integrate inverted pendulum equation: (CoM - ZMP) = (h/g) * CoM_ddot\n        # Rearranged: CoM_ddot = (g/h) * (CoM - ZMP)\n\n        for i in range(1, len(t)):\n            # Calculate acceleration based on ZMP-COM relationship\n            com_ddot_x = (self.g / self.robot_height) * (com_x[i-1] - zmp_x[i-1])\n            com_ddot_y = (self.g / self.robot_height) * (com_y[i-1] - zmp_y[i-1])\n\n            # Integrate to get velocity\n            com_dx[i] = com_dx[i-1] + com_ddot_x * dt\n            com_dy[i] = com_dy[i-1] + com_ddot_y * dt\n\n            # Integrate to get position\n            com_x[i] = com_x[i-1] + com_dx[i-1] * dt\n            com_y[i] = com_y[i-1] + com_dy[i-1] * dt\n\n        return t, com_x, com_y, com_dx, com_dy\n\n    def generate_foot_trajectory(self, footsteps, dt=0.01):\n        \"\"\"Generate smooth foot trajectories for walking\"\"\"\n        # For each footstep, create a trajectory from previous position to new position\n        # Include lift and swing phases\n\n        total_time = len(footsteps) * 1.0  # 1 second per step\n        t = np.arange(0, total_time, dt)\n\n        left_foot_x = np.zeros_like(t)\n        left_foot_y = np.zeros_like(t)\n        left_foot_z = np.zeros_like(t)\n        right_foot_x = np.zeros_like(t)\n        right_foot_y = np.zeros_like(t)\n        right_foot_z = np.zeros_like(t)\n\n        # Initialize feet positions\n        left_support = True  # Start with left foot as support\n        left_pos = [0, self.step_width/2, 0]\n        right_pos = [0, -self.step_width/2, 0]\n\n        for i, step in enumerate(footsteps):\n            step_start_idx = int(i / dt)\n            step_duration_idx = int(1.0 / dt)\n\n            if step_start_idx >= len(t):\n                break\n\n            end_idx = min(step_start_idx + step_duration_idx, len(t))\n\n            # Determine which foot is moving\n            moving_foot = step['foot']\n            target_pos = step['position']\n\n            # Generate trajectory for moving foot\n            for j in range(step_start_idx, end_idx):\n                time_in_step = (j - step_start_idx) * dt\n\n                # Swing phase: parabolic trajectory for smooth motion\n                if moving_foot == 'left':\n                    # Calculate swing trajectory\n                    swing_progress = min(time_in_step * 2, 1.0)  # 0 to 1 during swing\n                    if swing_progress < 1.0:\n                        # Lift phase (first half of swing)\n                        lift_progress = min(swing_progress * 2, 1.0)\n                        left_foot_z[j] = self.step_height * 4 * lift_progress * (1 - lift_progress)  # Parabolic lift\n                        left_foot_x[j] = left_pos[0] + (target_pos[0] - left_pos[0]) * swing_progress\n                        left_foot_y[j] = left_pos[1] + (target_pos[1] - left_pos[1]) * swing_progress\n                    else:\n                        left_foot_x[j] = target_pos[0]\n                        left_foot_y[j] = target_pos[1]\n                        left_foot_z[j] = 0  # On ground\n                else:  # right foot\n                    swing_progress = min(time_in_step * 2, 1.0)\n                    if swing_progress < 1.0:\n                        lift_progress = min(swing_progress * 2, 1.0)\n                        right_foot_z[j] = self.step_height * 4 * lift_progress * (1 - lift_progress)\n                        right_foot_x[j] = right_pos[0] + (target_pos[0] - right_pos[0]) * swing_progress\n                        right_foot_y[j] = right_pos[1] + (target_pos[1] - right_pos[1]) * swing_progress\n                    else:\n                        right_foot_x[j] = target_pos[0]\n                        right_foot_y[j] = target_pos[1]\n                        right_foot_z[j] = 0  # On ground\n\n            # Update the position of the moved foot\n            if moving_foot == 'left':\n                left_pos = [target_pos[0], target_pos[1], 0]\n            else:\n                right_pos = [target_pos[0], target_pos[1], 0]\n\n        return t, (left_foot_x, left_foot_y, left_foot_z), (right_foot_x, right_foot_y, right_foot_z)\n\n# Example usage\ndef example_zmp_walking():\n    generator = ZMPWalkingPatternGenerator()\n\n    # Generate footsteps\n    footsteps = generator.generate_footsteps(5)\n    print(\"Generated footsteps:\")\n    for step in footsteps:\n        print(f\"Step {step['step']}: {step['foot']} foot at {step['position']}\")\n\n    # Generate ZMP trajectory\n    zmp_trajectory = generator.calculate_zmp_trajectory(footsteps)\n\n    # Generate CoM trajectory\n    com_trajectory = generator.generate_com_trajectory(zmp_trajectory)\n\n    # Generate foot trajectories\n    foot_trajectories = generator.generate_foot_trajectory(footsteps)\n\n    # Plot results\n    t, com_x, com_y, _, _ = com_trajectory\n    t_zmp, zmp_x, zmp_y = zmp_trajectory\n\n    plt.figure(figsize=(12, 8))\n\n    # Plot CoM and ZMP trajectories\n    plt.subplot(2, 2, 1)\n    plt.plot(com_x, com_y, 'b-', label='CoM Trajectory', linewidth=2)\n    plt.plot(zmp_x, zmp_y, 'r--', label='ZMP Trajectory', linewidth=2)\n    plt.scatter([step['position'][0] for step in footsteps],\n                [step['position'][1] for step in footsteps],\n                c='g', s=100, label='Footsteps', zorder=5)\n    plt.xlabel('X Position (m)')\n    plt.ylabel('Y Position (m)')\n    plt.title('CoM and ZMP Trajectories')\n    plt.legend()\n    plt.grid(True)\n\n    # Plot X trajectories over time\n    plt.subplot(2, 2, 2)\n    plt.plot(t, com_x, label='CoM X', linewidth=2)\n    plt.plot(t_zmp, zmp_x, label='ZMP X', linestyle='--', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('X Trajectory Over Time')\n    plt.legend()\n    plt.grid(True)\n\n    # Plot Y trajectories over time\n    plt.subplot(2, 2, 3)\n    plt.plot(t, com_y, label='CoM Y', linewidth=2)\n    plt.plot(t_zmp, zmp_y, label='ZMP Y', linestyle='--', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Y Trajectory Over Time')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    example_zmp_walking()\n"})}),"\n",(0,o.jsx)(e.h3,{id:"footstep-planning-and-path-following",children:"Footstep Planning and Path Following"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# footstep_planning.py\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport matplotlib.pyplot as plt\n\nclass FootstepPlanner:\n    def __init__(self, step_length=0.3, step_width=0.2, max_turn=0.3):\n        self.step_length = step_length\n        self.step_width = step_width\n        self.max_turn = max_turn  # Maximum turning angle per step\n\n    def plan_path_footsteps(self, path, start_pos, start_yaw):\n        \"\"\"Plan footsteps along a given path\"\"\"\n        footsteps = []\n        current_pos = np.array(start_pos)\n        current_yaw = start_yaw\n\n        # Start with current foot positions\n        left_foot = current_pos + np.array([0, self.step_width/2])\n        right_foot = current_pos + np.array([0, -self.step_width/2])\n\n        # Determine which foot to step with first\n        use_left = True  # Start with left foot\n\n        path_idx = 0\n        while path_idx < len(path) - 1:\n            # Calculate direction to next path point\n            target = np.array(path[path_idx])\n            direction = target - current_pos\n            distance = np.linalg.norm(direction)\n\n            if distance < 0.1:  # Close enough to path point\n                path_idx += 1\n                continue\n\n            # Normalize direction\n            direction = direction / distance\n\n            # Calculate desired step position\n            step_x = current_pos[0] + self.step_length * direction[0]\n            step_y = current_pos[1] + self.step_length * direction[1]\n\n            # Add some turning capability\n            target_yaw = np.arctan2(direction[1], direction[0])\n            yaw_diff = target_yaw - current_yaw\n\n            # Limit turning per step\n            if abs(yaw_diff) > self.max_turn:\n                yaw_diff = np.sign(yaw_diff) * self.max_turn\n\n            current_yaw += yaw_diff\n\n            # Calculate foot position with turning\n            if use_left:\n                foot_pos = np.array([step_x, step_y + self.step_width/2])\n                foot = 'left'\n            else:\n                foot_pos = np.array([step_x, step_y - self.step_width/2])\n                foot = 'right'\n\n            # Check if step is feasible (not too far from supporting foot)\n            support_foot = right_foot if use_left else left_foot\n            step_distance_from_support = np.linalg.norm(foot_pos - support_foot)\n\n            if step_distance_from_support <= 0.5:  # Max step distance\n                footsteps.append({\n                    'step': len(footsteps) + 1,\n                    'foot': foot,\n                    'position': foot_pos.copy(),\n                    'yaw': current_yaw\n                })\n\n                # Update supporting foot position\n                if use_left:\n                    left_foot = foot_pos.copy()\n                else:\n                    right_foot = foot_pos.copy()\n\n                # Move robot position forward\n                current_pos = foot_pos.copy()\n\n                # Switch feet\n                use_left = not use_left\n\n            else:\n                # If step is too large, try a smaller step\n                adjusted_pos = support_foot + 0.4 * direction  # Reduce step size\n                footsteps.append({\n                    'step': len(footsteps) + 1,\n                    'foot': 'left' if use_left else 'right',\n                    'position': adjusted_pos,\n                    'yaw': current_yaw\n                })\n\n                if use_left:\n                    left_foot = adjusted_pos.copy()\n                else:\n                    right_foot = adjusted_pos.copy()\n\n                current_pos = adjusted_pos.copy()\n                use_left = not use_left\n\n            path_idx += 1\n\n        return footsteps\n\n    def optimize_footsteps(self, footsteps):\n        \"\"\"Optimize footsteps to improve stability and efficiency\"\"\"\n        if len(footsteps) < 2:\n            return footsteps\n\n        optimized = [footsteps[0]]  # Keep first step\n\n        for i in range(1, len(footsteps)):\n            current = footsteps[i]\n            previous = optimized[-1]\n\n            # Calculate ideal position based on gait pattern\n            dx = current['position'][0] - previous['position'][0]\n            dy = current['position'][1] - previous['position'][1]\n\n            # Ensure alternating feet\n            if current['foot'] == previous['foot']:\n                # This shouldn't happen in proper planning, but fix if needed\n                current['foot'] = 'right' if current['foot'] == 'left' else 'left'\n\n            # Apply stability constraints\n            distance_from_prev = np.sqrt(dx**2 + dy**2)\n            if distance_from_prev > 0.4:  # Too far, adjust\n                direction = np.array([dx, dy]) / distance_from_prev\n                adjusted_pos = np.array(previous['position']) + 0.3 * direction\n                current['position'] = adjusted_pos\n\n            optimized.append(current)\n\n        return optimized\n\n    def check_stability(self, footsteps):\n        \"\"\"Check if the footstep sequence is stable\"\"\"\n        if len(footsteps) < 2:\n            return True\n\n        stable = True\n        reasons = []\n\n        for i in range(1, len(footsteps)):\n            current = footsteps[i]\n            previous = footsteps[i-1]\n\n            # Check step size\n            step_distance = np.linalg.norm(\n                np.array(current['position']) - np.array(previous['position'])\n            )\n\n            if step_distance > 0.4:  # Too large a step\n                stable = False\n                reasons.append(f\"Step {i}: Distance {step_distance:.2f}m too large\")\n\n            # Check foot placement relative to body\n            # For now, just check that feet alternate appropriately\n            if current['foot'] == previous['foot']:\n                stable = False\n                reasons.append(f\"Step {i}: Same foot as previous step\")\n\n        return stable, reasons\n\n# Example usage\ndef example_footstep_planning():\n    planner = FootstepPlanner()\n\n    # Define a simple path (x, y coordinates)\n    path = [\n        [0, 0],\n        [1, 0],\n        [2, 0.5],\n        [3, 1],\n        [4, 1.5],\n        [5, 1.5]\n    ]\n\n    # Plan footsteps\n    footsteps = planner.plan_path_footsteps(path, start_pos=[0, 0], start_yaw=0)\n\n    # Optimize footsteps\n    optimized_footsteps = planner.optimize_footsteps(footsteps)\n\n    # Check stability\n    stable, reasons = planner.check_stability(optimized_footsteps)\n\n    print(\"Footstep planning results:\")\n    print(f\"Stable: {stable}\")\n    if reasons:\n        for reason in reasons:\n            print(f\"  - {reason}\")\n\n    print(f\"\\nPlanned footsteps ({len(optimized_footsteps)} total):\")\n    for step in optimized_footsteps:\n        print(f\"  Step {step['step']}: {step['foot']} foot at ({step['position'][0]:.2f}, {step['position'][1]:.2f})\")\n\nif __name__ == \"__main__\":\n    example_footstep_planning()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"balance-control-mechanisms",children:"Balance Control Mechanisms"}),"\n",(0,o.jsx)(e.h3,{id:"center-of-mass-control",children:"Center of Mass Control"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# balance_control.py\nimport numpy as np\nfrom math import sin, cos, atan2\n\nclass BalanceController:\n    def __init__(self, robot_height=0.8, control_frequency=100):\n        self.robot_height = robot_height\n        self.control_frequency = control_frequency\n        self.dt = 1.0 / control_frequency\n\n        # PID gains for balance control\n        self.com_x_pid = self.PIDController(kp=800, ki=10, kd=200)\n        self.com_y_pid = self.PIDController(kp=800, ki=10, kd=200)\n        self.com_z_pid = self.PIDController(kp=500, ki=5, kd=100)  # For height control\n\n        # State variables\n        self.current_com = np.array([0.0, 0.0, robot_height])\n        self.desired_com = np.array([0.0, 0.0, robot_height])\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\n\n        # ZMP-based balance control\n        self.zmp_error_integrator = np.array([0.0, 0.0])\n        self.zmp_error_derivative = np.array([0.0, 0.0])\n        self.previous_zmp_error = np.array([0.0, 0.0])\n\n    class PIDController:\n        def __init__(self, kp, ki, kd):\n            self.kp = kp\n            self.ki = ki\n            self.kd = kd\n            self.integral = 0\n            self.previous_error = 0\n\n        def compute(self, error, dt):\n            self.integral += error * dt\n            derivative = (error - self.previous_error) / dt if dt > 0 else 0\n\n            output = self.kp * error + self.ki * self.integral + self.kd * derivative\n\n            self.previous_error = error\n            return output\n\n    def update_balance(self, current_com, current_zmp, desired_zmp, dt=None):\n        """Update balance control based on CoM and ZMP errors"""\n        if dt is None:\n            dt = self.dt\n\n        # Calculate errors\n        com_error = self.desired_com - current_com\n        zmp_error = desired_zmp - current_zmp\n\n        # Update ZMP error integrator and derivative\n        self.zmp_error_integrator += zmp_error * dt\n        if dt > 0:\n            self.zmp_error_derivative = (zmp_error - self.previous_zmp_error) / dt\n        self.previous_zmp_error = zmp_error.copy()\n\n        # Compute balance corrections using PID control\n        balance_correction = np.zeros(3)\n\n        # X-axis balance (using ZMP error to correct CoM)\n        balance_correction[0] = self.com_x_pid.compute(zmp_error[0], dt)\n\n        # Y-axis balance (using ZMP error to correct CoM)\n        balance_correction[1] = self.com_y_pid.compute(zmp_error[1], dt)\n\n        # Z-axis (height) control\n        height_error = self.desired_com[2] - current_com[2]\n        balance_correction[2] = self.com_z_pid.compute(height_error, dt)\n\n        # Apply limits to prevent excessive corrections\n        max_correction = 0.05  # 5cm max correction per step\n        balance_correction = np.clip(balance_correction, -max_correction, max_correction)\n\n        # Update desired CoM position based on corrections\n        self.desired_com += balance_correction * dt * 10  # Scale appropriately\n\n        return balance_correction\n\n    def compute_ankle_torque_balance(self, com_error, zmp_error):\n        """Compute ankle torques for balance based on CoM and ZMP errors"""\n        # Map CoM and ZMP errors to ankle torques\n        # This is a simplified model - in practice, this would involve more complex kinematics\n\n        ankle_torques = {}\n\n        # Left ankle corrections\n        ankle_torques[\'left_ankle_pitch\'] = -100 * com_error[1] - 50 * zmp_error[1]  # Y-direction balance\n        ankle_torques[\'left_ankle_roll\'] = -100 * com_error[0] - 50 * zmp_error[0]   # X-direction balance\n\n        # Right ankle corrections\n        ankle_torques[\'right_ankle_pitch\'] = -100 * com_error[1] - 50 * zmp_error[1]  # Y-direction balance\n        ankle_torques[\'right_ankle_roll\'] = -100 * com_error[0] - 50 * zmp_error[0]   # X-direction balance\n\n        return ankle_torques\n\n    def compute_hip_balance(self, com_error, zmp_error):\n        """Compute hip adjustments for balance"""\n        hip_adjustments = {}\n\n        # Hip pitch for forward/backward balance\n        hip_adjustments[\'left_hip_pitch\'] = -50 * com_error[0] - 25 * zmp_error[0]\n        hip_adjustments[\'right_hip_pitch\'] = -50 * com_error[0] - 25 * zmp_error[0]\n\n        # Hip roll for lateral balance\n        hip_adjustments[\'left_hip_roll\'] = -40 * com_error[1] - 20 * zmp_error[1]\n        hip_adjustments[\'right_hip_roll\'] = 40 * com_error[1] + 20 * zmp_error[1]  # Opposite for right hip\n\n        return hip_adjustments\n\n    def compute_balance_strategy(self, com_pos, zmp_pos, support_polygon):\n        """Determine appropriate balance strategy based on current state"""\n        # Calculate distance from CoM to support polygon\n        com_xy = com_pos[:2]\n\n        # Simple check if CoM is within support polygon (simplified for rectangular support)\n        if len(support_polygon) >= 2:\n            min_x = min(p[0] for p in support_polygon)\n            max_x = max(p[0] for p in support_polygon)\n            min_y = min(p[1] for p in support_polygon)\n            max_y = max(p[1] for p in support_polygon)\n\n            com_in_support = (min_x <= com_xy[0] <= max_x) and (min_y <= com_xy[1] <= max_y)\n        else:\n            com_in_support = False\n\n        # Determine balance strategy\n        if not com_in_support:\n            # Emergency balance strategy - large corrections needed\n            strategy = \'emergency_balance\'\n            margin = min(\n                abs(com_xy[0] - min_x), abs(max_x - com_xy[0]),\n                abs(com_xy[1] - min_y), abs(max_y - com_xy[1])\n            )\n        else:\n            # Normal balance - small adjustments\n            strategy = \'normal_balance\'\n            margin = 0.1  # Default safety margin\n\n        return {\n            \'strategy\': strategy,\n            \'margin\': margin,\n            \'com_in_support\': com_in_support\n        }\n\n    def adjust_step_timing(self, balance_state):\n        """Adjust step timing based on balance state"""\n        if balance_state[\'strategy\'] == \'emergency_balance\':\n            # Speed up step timing to recover balance faster\n            return 0.8  # 80% of normal step time\n        else:\n            # Normal step timing\n            return 1.0\n\nclass InvertedPendulumBalancer:\n    """Advanced balance controller using inverted pendulum model"""\n    def __init__(self, com_height=0.8, control_frequency=200):\n        self.com_height = com_height\n        self.omega = np.sqrt(9.81 / com_height)  # Natural frequency\n        self.control_frequency = control_frequency\n        self.dt = 1.0 / control_frequency\n\n        # State: [x, x_dot, y, y_dot] where x,y are CoM positions\n        self.state = np.zeros(4)\n\n        # Desired state\n        self.desired_state = np.zeros(4)\n\n        # Control gains (LQR-based, simplified)\n        self.K = np.array([1.0, 0.1, 1.0, 0.1])  # Simplified gains\n\n    def update(self, measured_com_pos, measured_com_vel, desired_com_pos, dt=None):\n        """Update inverted pendulum balance controller"""\n        if dt is None:\n            dt = self.dt\n\n        # Update state vector [x, x_dot, y, y_dot]\n        self.state[0] = measured_com_pos[0]  # x position\n        self.state[1] = measured_com_vel[0]  # x velocity\n        self.state[2] = measured_com_pos[1]  # y position\n        self.state[3] = measured_com_vel[1]  # y velocity\n\n        # Update desired state\n        self.desired_state[0] = desired_com_pos[0]\n        self.desired_state[2] = desired_com_pos[1]\n\n        # Calculate error\n        error = self.desired_state - self.state\n\n        # Simple control law (in practice, this would be more sophisticated)\n        zmp_correction = self.K * error\n\n        # Convert to ZMP command\n        zmp_cmd = np.array([\n            self.desired_state[0] - zmp_correction[0] / (self.omega**2),\n            self.desired_state[2] - zmp_correction[2] / (self.omega**2)\n        ])\n\n        return zmp_cmd\n\n# Example usage\ndef example_balance_control():\n    balance_controller = BalanceController()\n    pendulum_balancer = InvertedPendulumBalancer()\n\n    # Simulate some CoM and ZMP measurements\n    current_com = np.array([0.02, -0.01, 0.79])  # Slightly off balance\n    current_zmp = np.array([0.01, -0.005])  # ZMP slightly off\n    desired_zmp = np.array([0.0, 0.0])  # Want ZMP at origin\n\n    # Update balance control\n    balance_correction = balance_controller.update_balance(\n        current_com, current_zmp, desired_zmp\n    )\n\n    print(f"Balance correction: {balance_correction}")\n\n    # Compute ankle torques\n    com_error = np.array([0.02, -0.01, 0])  # X, Y, Z errors\n    ankle_torques = balance_controller.compute_ankle_torque_balance(com_error[:2],\n                                                                 desired_zmp - current_zmp)\n\n    print(f"Ankle torques: {ankle_torques}")\n\n    # Test inverted pendulum balancer\n    desired_com = np.array([0.0, 0.0, 0.8])\n    com_vel = np.array([0.01, -0.005, 0.0])  # Small velocities\n\n    zmp_cmd = pendulum_balancer.update(current_com, com_vel, desired_com)\n    print(f"ZMP command from inverted pendulum: {zmp_cmd}")\n\nif __name__ == "__main__":\n    example_balance_control()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"stability-control-algorithms",children:"Stability Control Algorithms"}),"\n",(0,o.jsx)(e.h3,{id:"capture-point-and-divergent-component-of-motion",children:"Capture Point and Divergent Component of Motion"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# stability_algorithms.py\nimport numpy as np\nfrom math import sqrt, exp\n\nclass CapturePointController:\n    """Controller based on Capture Point theory for humanoid balance"""\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = sqrt(gravity / com_height)\n\n    def compute_capture_point(self, com_pos, com_vel):\n        """Compute capture point from current CoM state"""\n        # Capture point = CoM position + CoM velocity / omega\n        capture_point = com_pos + com_vel / self.omega\n        return capture_point\n\n    def is_stable(self, com_pos, com_vel, support_polygon):\n        """Check if current state is stable based on capture point"""\n        capture_point = self.compute_capture_point(com_pos[:2], com_vel[:2])\n\n        # Check if capture point is within support polygon\n        # Simplified for rectangular support\n        if len(support_polygon) >= 2:\n            min_x = min(p[0] for p in support_polygon)\n            max_x = max(p[0] for p in support_polygon)\n            min_y = min(p[1] for p in support_polygon)\n            max_y = max(p[1] for p in support_polygon)\n\n            return (min_x <= capture_point[0] <= max_x) and (min_y <= capture_point[1] <= max_y)\n\n        return False\n\n    def compute_stabilizing_step(self, com_pos, com_vel, support_polygon):\n        """Compute where to step to achieve stability"""\n        capture_point = self.compute_capture_point(com_pos[:2], com_vel[:2])\n\n        # For stability, step should be placed at or beyond the capture point\n        # Add a safety margin\n        safety_margin = 0.05  # 5cm safety margin\n\n        # Calculate step location\n        step_location = capture_point + safety_margin * (capture_point - com_pos[:2]) / \\\n                       np.linalg.norm(capture_point - com_pos[:2] + 1e-6)\n\n        # Ensure step is within reasonable bounds\n        step_location[0] = np.clip(step_location[0], -0.3, 0.3)  # Limit step size\n        step_location[1] = np.clip(step_location[1], -0.2, 0.2)\n\n        return step_location\n\nclass DCMController:\n    """Controller based on Divergent Component of Motion (DCM)"""\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = sqrt(gravity / com_height)\n\n    def compute_dcm(self, com_pos, com_vel):\n        """Compute Divergent Component of Motion"""\n        # DCM = CoM position + CoM velocity / omega\n        dcm = com_pos + com_vel / self.omega\n        return dcm\n\n    def compute_desired_dcm(self, target_pos, time_to_switch):\n        """Compute desired DCM to reach target in given time"""\n        # For exponential convergence: DCM_desired = target + (current_DCM - target) * exp(-omega * t)\n        current_dcm = self.compute_dcm(self.current_com_pos, self.current_com_vel)\n        desired_dcm = target_pos + (current_dcm - target_pos) * exp(-self.omega * time_to_switch)\n        return desired_dcm\n\n    def compute_balance_feedback(self, current_dcm, desired_dcm, dt):\n        """Compute feedback control based on DCM error"""\n        dcm_error = desired_dcm - current_dcm\n\n        # Simple proportional control\n        feedback_gain = 10.0  # Adjust based on robot properties\n        com_adjustment = feedback_gain * dcm_error * dt\n\n        return com_adjustment\n\nclass WalkingStabilizer:\n    """Comprehensive walking stabilizer using multiple techniques"""\n    def __init__(self, com_height=0.8):\n        self.com_height = com_height\n        self.capture_point_controller = CapturePointController(com_height)\n        self.dcm_controller = DCMController(com_height)\n\n        # Walking state\n        self.current_support_foot = \'left\'\n        self.swing_foot = \'right\'\n        self.step_time = 1.0  # Time per step\n        self.time_in_step = 0.0\n\n        # Balance margins\n        self.stability_margin = 0.05  # 5cm margin\n        self.max_com_velocity = 0.5   # 0.5 m/s max CoM velocity\n\n    def update_stabilization(self, com_pos, com_vel, support_polygon, dt):\n        """Update stabilization strategy"""\n        self.time_in_step += dt\n\n        # Check stability using multiple methods\n        cp_stable = self.capture_point_controller.is_stable(com_pos, com_vel, support_polygon)\n        dcm = self.dcm_controller.compute_dcm(com_pos[:2], com_vel[:2])\n\n        # Determine if we need to take a step to maintain balance\n        need_step = not cp_stable\n\n        # Calculate step location if needed\n        step_location = None\n        if need_step:\n            step_location = self.capture_point_controller.compute_stabilizing_step(\n                com_pos, com_vel, support_polygon\n            )\n\n        # Calculate CoM adjustments\n        com_adjustment = self.calculate_com_adjustment(com_pos, com_vel, dcm, support_polygon)\n\n        # Calculate timing adjustments\n        timing_factor = self.calculate_timing_adjustment(com_pos, com_vel, cp_stable)\n\n        return {\n            \'need_step\': need_step,\n            \'step_location\': step_location,\n            \'com_adjustment\': com_adjustment,\n            \'timing_factor\': timing_factor,\n            \'capture_point\': self.capture_point_controller.compute_capture_point(com_pos[:2], com_vel[:2]),\n            \'dcm\': dcm,\n            \'stable\': cp_stable\n        }\n\n    def calculate_com_adjustment(self, com_pos, com_vel, dcm, support_polygon):\n        """Calculate CoM adjustments for stability"""\n        adjustments = np.zeros(3)\n\n        # DCM-based adjustment\n        # Want to move DCM toward center of support polygon\n        if len(support_polygon) >= 2:\n            support_center = np.mean(support_polygon, axis=0)\n            dcm_error = support_center - dcm\n\n            # Apply feedback to move CoM appropriately\n            adjustments[0] = 0.5 * dcm_error[0]  # X adjustment\n            adjustments[1] = 0.5 * dcm_error[1]  # Y adjustment\n\n        # Velocity damping\n        max_velocity = self.max_com_velocity\n        if abs(com_vel[0]) > max_velocity:\n            adjustments[0] -= 0.1 * (abs(com_vel[0]) - max_velocity) * np.sign(com_vel[0])\n        if abs(com_vel[1]) > max_velocity:\n            adjustments[1] -= 0.1 * (abs(com_vel[1]) - max_velocity) * np.sign(com_vel[1])\n\n        # Limit adjustments\n        adjustments = np.clip(adjustments, -0.02, 0.02)  # \xb12cm adjustments\n\n        return adjustments\n\n    def calculate_timing_adjustment(self, com_pos, com_vel, stable):\n        """Calculate step timing adjustments based on stability"""\n        if stable:\n            # If stable, maintain normal timing\n            return 1.0\n        else:\n            # If unstable, speed up to recover balance faster\n            com_speed = np.linalg.norm(com_vel[:2])\n            if com_speed > 0.3:  # If moving fast\n                return 0.8  # 80% of normal time\n            else:\n                return 0.9  # 90% of normal time\n\n# Example usage\ndef example_stability_algorithms():\n    stabilizer = WalkingStabilizer()\n\n    # Simulate robot state\n    com_pos = np.array([0.03, -0.02, 0.79])  # CoM slightly off\n    com_vel = np.array([0.05, -0.03, 0.0])   # CoM moving\n    support_polygon = np.array([[-0.05, 0.1], [-0.05, -0.1]])  # Simple rectangular support\n\n    # Update stabilization\n    dt = 0.01  # 100Hz control\n    stability_info = stabilizer.update_stabilization(com_pos, com_vel, support_polygon, dt)\n\n    print("Stability Analysis:")\n    print(f"  Stable: {stability_info[\'stable\']}")\n    print(f"  Need step: {stability_info[\'need_step\']}")\n    print(f"  Capture Point: {stability_info[\'capture_point\']}")\n    print(f"  DCM: {stability_info[\'dcm\']}")\n    print(f"  CoM adjustment: {stability_info[\'com_adjustment\']}")\n    print(f"  Timing factor: {stability_info[\'timing_factor\']}")\n\n    if stability_info[\'step_location\'] is not None:\n        print(f"  Recommended step location: {stability_info[\'step_location\']}")\n\nif __name__ == "__main__":\n    example_stability_algorithms()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"walking-pattern-implementation",children:"Walking Pattern Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"pattern-generators-and-interpolation",children:"Pattern Generators and Interpolation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# walking_patterns.py\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\nimport matplotlib.pyplot as plt\n\nclass WalkingPatternGenerator:\n    \"\"\"Generate complete walking patterns with smooth interpolation\"\"\"\n    def __init__(self, com_height=0.8, step_time=1.0, dsp_ratio=0.1):\n        self.com_height = com_height\n        self.step_time = step_time\n        self.dsp_ratio = dsp_ratio  # Double support phase ratio\n        self.ssp_ratio = 1.0 - dsp_ratio  # Single support phase ratio\n\n        # Walking parameters\n        self.step_length = 0.3  # m\n        self.step_width = 0.2   # m\n        self.step_height = 0.05 # m\n        self.com_height_variation = 0.02  # m (up and down motion)\n\n    def generate_com_trajectory(self, steps, start_pos=(0, 0, 0.8)):\n        \"\"\"Generate CoM trajectory for multiple steps\"\"\"\n        # Total time\n        total_time = len(steps) * self.step_time\n\n        # Time vector\n        t = np.linspace(0, total_time, int(total_time * 200))  # 200Hz sampling\n\n        # Initialize trajectory arrays\n        com_x = np.zeros_like(t)\n        com_y = np.zeros_like(t)\n        com_z = np.zeros_like(t)\n\n        # Start position\n        current_x, current_y, current_z = start_pos\n\n        # Generate trajectory for each step\n        for i, step in enumerate(steps):\n            step_start_time = i * self.step_time\n            step_end_time = (i + 1) * self.step_time\n\n            # Find time indices for this step\n            step_indices = np.where((t >= step_start_time) & (t < step_end_time))[0]\n\n            if len(step_indices) == 0:\n                continue\n\n            step_t = t[step_indices]\n            step_duration = step_end_time - step_start_time\n\n            # X trajectory - follows walking direction\n            if i == 0:\n                # Start at initial position\n                com_x[step_indices] = current_x + (step['position'][0] - current_x) * \\\n                    (step_t - step_start_time) / step_duration\n            else:\n                # Smooth transition between steps\n                start_x = com_x[step_indices[0] - 1] if step_indices[0] > 0 else current_x\n                com_x[step_indices] = start_x + (step['position'][0] - start_x) * \\\n                    (step_t - step_start_time) / step_duration\n\n            # Y trajectory - maintains balance between feet\n            support_foot_y = step['position'][1]\n            if step['foot'] == 'left':\n                # Left foot support, CoM shifts slightly right\n                target_y = support_foot_y - 0.02\n            else:\n                # Right foot support, CoM shifts slightly left\n                target_y = support_foot_y + 0.02\n\n            # Smooth transition to target Y\n            if step_indices[0] > 0:\n                start_y = com_y[step_indices[0] - 1]\n            else:\n                start_y = start_pos[1]\n\n            com_y[step_indices] = start_y + (target_y - start_y) * \\\n                (step_t - step_start_time) / step_duration\n\n            # Z trajectory - slight up/down motion for natural walking\n            # Oscillate at walking frequency\n            omega = 2 * np.pi / self.step_time\n            z_variation = self.com_height_variation * np.sin(omega * (step_t - step_start_time))\n            com_z[step_indices] = self.com_height + z_variation\n\n        return t, com_x, com_y, com_z\n\n    def generate_foot_trajectory(self, steps, foot_type='left'):\n        \"\"\"Generate smooth foot trajectory for a specific foot\"\"\"\n        total_time = len(steps) * self.step_time\n        t = np.linspace(0, total_time, int(total_time * 200))\n\n        foot_x = np.zeros_like(t)\n        foot_y = np.zeros_like(t)\n        foot_z = np.zeros_like(t)\n\n        # Find steps where this foot is moving (not supporting)\n        moving_steps = []\n        for i, step in enumerate(steps):\n            if step['foot'] == foot_type:\n                moving_steps.append((i, step))\n\n        # Set initial position to first supporting position\n        for i, step in enumerate(steps):\n            if step['foot'] != foot_type:  # Supporting foot\n                initial_pos = step['position']\n                break\n        else:\n            initial_pos = (0, 0)  # Default if no supporting step found\n\n        # Initialize with supporting position\n        foot_x.fill(initial_pos[0])\n        foot_y.fill(initial_pos[1])\n        foot_z.fill(0)  # On ground when supporting\n\n        # Generate trajectories for each time the foot moves\n        for step_idx, (move_step_idx, move_step) in enumerate(moving_steps):\n            # When this foot moves, it goes from previous support position to new position\n            start_time = move_step_idx * self.step_time\n            end_time = (move_step_idx + 1) * self.step_time\n\n            # Find indices for this step\n            step_indices = np.where((t >= start_time) & (t < end_time))[0]\n\n            if len(step_indices) == 0:\n                continue\n\n            step_t = t[step_indices]\n\n            # Find the previous support position (position of other foot)\n            if move_step_idx > 0:\n                prev_support = steps[move_step_idx - 1]\n                if prev_support['foot'] != foot_type:\n                    prev_pos = prev_support['position']\n                else:\n                    # This shouldn't happen in proper alternating gait\n                    prev_pos = initial_pos\n            else:\n                prev_pos = initial_pos\n\n            # Calculate swing trajectory\n            # Use parabolic trajectory for foot lift\n            for j, time_idx in enumerate(step_indices):\n                local_t = (t[time_idx] - start_time) / self.step_time  # 0 to 1\n\n                if local_t < self.dsp_ratio:\n                    # Double support phase - foot still on ground\n                    foot_x[time_idx] = prev_pos[0]\n                    foot_y[time_idx] = prev_pos[1]\n                    foot_z[time_idx] = 0\n                elif local_t < self.dsp_ratio + self.ssp_ratio:\n                    # Single support phase - foot swings\n                    swing_t = (local_t - self.dsp_ratio) / self.ssp_ratio  # 0 to 1 in swing phase\n\n                    # Parabolic trajectory in X and Y\n                    foot_x[time_idx] = prev_pos[0] + (move_step['position'][0] - prev_pos[0]) * swing_t\n                    foot_y[time_idx] = prev_pos[1] + (move_step['position'][1] - prev_pos[1]) * swing_t\n\n                    # Parabolic lift in Z (swing phase)\n                    lift_shape = 4 * swing_t * (1 - swing_t)  # Parabola from 0 to 1\n                    foot_z[time_idx] = self.step_height * lift_shape\n                else:\n                    # Second double support phase - foot lands\n                    foot_x[time_idx] = move_step['position'][0]\n                    foot_y[time_idx] = move_step['position'][1]\n                    foot_z[time_idx] = 0  # On ground\n\n        return t, foot_x, foot_y, foot_z\n\n    def generate_joints_from_cartesian(self, com_trajectory, left_foot_trajectory, right_foot_trajectory):\n        \"\"\"Generate joint angles from Cartesian trajectories using inverse kinematics\"\"\"\n        # This would typically use inverse kinematics solvers\n        # For simplicity, we'll return placeholder joint trajectories\n        t, com_x, com_y, com_z = com_trajectory\n        _, lf_x, lf_y, lf_z = left_foot_trajectory\n        _, rf_x, rf_y, rf_z = right_foot_trajectory\n\n        # Placeholder: return time vector and some joint data\n        # In practice, this would solve inverse kinematics for each time step\n        joint_trajectories = {\n            'time': t,\n            'left_hip_pitch': np.zeros_like(t),\n            'left_knee': np.zeros_like(t),\n            'left_ankle_pitch': np.zeros_like(t),\n            'right_hip_pitch': np.zeros_like(t),\n            'right_knee': np.zeros_like(t),\n            'right_ankle_pitch': np.zeros_like(t),\n        }\n\n        # Generate simple joint patterns based on foot trajectories\n        for i in range(len(t)):\n            # Simple inverse kinematics approximation\n            # Left leg\n            leg_length = 0.75  # Approximate leg length\n            left_foot_height = lf_z[i]\n            if left_foot_height < 0.01:  # Foot on ground\n                # Calculate approximate joint angles\n                hip_pitch = np.arcsin(min(0.3, max(-0.3, (0.1 - com_z[i] + 0.1) / leg_length)))\n                knee_angle = -2 * hip_pitch  # Simplified\n                ankle_angle = -hip_pitch\n            else:  # Foot in air\n                hip_pitch = 0.1\n                knee_angle = -0.2\n                ankle_angle = 0.05\n\n            joint_trajectories['left_hip_pitch'][i] = hip_pitch\n            joint_trajectories['left_knee'][i] = knee_angle\n            joint_trajectories['left_ankle_pitch'][i] = ankle_angle\n\n            # Right leg (similar calculation)\n            if rf_z[i] < 0.01:  # Foot on ground\n                hip_pitch = np.arcsin(min(0.3, max(-0.3, (0.1 - com_z[i] + 0.1) / leg_length)))\n                knee_angle = -2 * hip_pitch\n                ankle_angle = -hip_pitch\n            else:\n                hip_pitch = 0.1\n                knee_angle = -0.2\n                ankle_angle = 0.05\n\n            joint_trajectories['right_hip_pitch'][i] = hip_pitch\n            joint_trajectories['right_knee'][i] = knee_angle\n            joint_trajectories['right_ankle_pitch'][i] = ankle_angle\n\n        return joint_trajectories\n\nclass SmoothTrajectoryGenerator:\n    \"\"\"Generate smooth trajectories using splines\"\"\"\n    def __init__(self):\n        pass\n\n    def generate_spline_trajectory(self, waypoints, duration, frequency=200):\n        \"\"\"Generate smooth trajectory using cubic splines\"\"\"\n        if len(waypoints) < 2:\n            return np.array([0]), np.array([waypoints[0]]) if waypoints else np.array([0])\n\n        # Create time vector\n        t_total = duration\n        t = np.linspace(0, t_total, int(t_total * frequency))\n\n        # Separate waypoints by dimension\n        if isinstance(waypoints[0], (list, tuple, np.ndarray)):\n            n_dims = len(waypoints[0])\n            waypoint_times = np.linspace(0, t_total, len(waypoints))\n\n            trajectory = np.zeros((len(t), n_dims))\n\n            for dim in range(n_dims):\n                waypoint_values = [wp[dim] for wp in waypoints]\n                spline = CubicSpline(waypoint_times, waypoint_values)\n                trajectory[:, dim] = spline(t)\n        else:\n            # Single dimension\n            waypoint_times = np.linspace(0, t_total, len(waypoints))\n            spline = CubicSpline(waypoint_times, waypoints)\n            trajectory = spline(t)\n\n        return t, trajectory\n\n# Example usage\ndef example_walking_patterns():\n    # Create pattern generator\n    pattern_gen = WalkingPatternGenerator()\n\n    # Create some example footsteps\n    footsteps = [\n        {'step': 1, 'foot': 'left', 'position': (0.3, 0.1), 'yaw': 0},\n        {'step': 2, 'foot': 'right', 'position': (0.6, -0.1), 'yaw': 0},\n        {'step': 3, 'foot': 'left', 'position': (0.9, 0.1), 'yaw': 0},\n        {'step': 4, 'foot': 'right', 'position': (1.2, -0.1), 'yaw': 0},\n    ]\n\n    # Generate CoM trajectory\n    com_trajectory = pattern_gen.generate_com_trajectory(footsteps)\n\n    # Generate foot trajectories\n    left_foot_trajectory = pattern_gen.generate_foot_trajectory(footsteps, 'left')\n    right_foot_trajectory = pattern_gen.generate_foot_trajectory(footsteps, 'right')\n\n    # Generate joint trajectories\n    joint_trajectories = pattern_gen.generate_joints_from_cartesian(\n        com_trajectory, left_foot_trajectory, right_foot_trajectory\n    )\n\n    # Plot results\n    t, com_x, com_y, com_z = com_trajectory\n\n    plt.figure(figsize=(15, 10))\n\n    # Plot CoM trajectory\n    plt.subplot(2, 3, 1)\n    plt.plot(com_x, com_y, 'b-', linewidth=2, label='CoM Path')\n    for step in footsteps:\n        color = 'red' if step['foot'] == 'left' else 'green'\n        plt.scatter([step['position'][0]], [step['position'][1]],\n                   c=color, s=100, label=f\"{step['foot']} foot\", zorder=5)\n    plt.xlabel('X Position (m)')\n    plt.ylabel('Y Position (m)')\n    plt.title('CoM and Footstep Trajectory')\n    plt.legend()\n    plt.grid(True)\n\n    # Plot CoM height over time\n    plt.subplot(2, 3, 2)\n    plt.plot(t, com_z, 'b-', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Height (m)')\n    plt.title('CoM Height Over Time')\n    plt.grid(True)\n\n    # Plot foot trajectories\n    t_f, lf_x, lf_y, lf_z = left_foot_trajectory\n    t_f, rf_x, rf_y, rf_z = right_foot_trajectory\n\n    plt.subplot(2, 3, 3)\n    plt.plot(t_f, lf_z, label='Left Foot Z', linewidth=2)\n    plt.plot(t_f, rf_z, label='Right Foot Z', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Height (m)')\n    plt.title('Foot Z Trajectories')\n    plt.legend()\n    plt.grid(True)\n\n    # Plot joint trajectories\n    plt.subplot(2, 3, 4)\n    plt.plot(joint_trajectories['time'], joint_trajectories['left_hip_pitch'],\n             label='Left Hip Pitch', linewidth=2)\n    plt.plot(joint_trajectories['time'], joint_trajectories['right_hip_pitch'],\n             label='Right Hip Pitch', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Angle (rad)')\n    plt.title('Hip Pitch Trajectories')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(2, 3, 5)\n    plt.plot(joint_trajectories['time'], joint_trajectories['left_knee'],\n             label='Left Knee', linewidth=2)\n    plt.plot(joint_trajectories['time'], joint_trajectories['right_knee'],\n             label='Right Knee', linewidth=2)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Angle (rad)')\n    plt.title('Knee Angle Trajectories')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n    print(f\"Generated trajectories for {len(footsteps)} steps\")\n    print(f\"Total simulation time: {len(joint_trajectories['time']) / 200:.1f} seconds\")\n    print(f\"Trajectory points: {len(joint_trajectories['time'])}\")\n\nif __name__ == \"__main__\":\n    example_walking_patterns()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"knowledge-check",children:"Knowledge Check"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"What is the Zero Moment Point (ZMP) and why is it crucial for bipedal walking?"}),"\n",(0,o.jsx)(e.li,{children:"How do Capture Point and Divergent Component of Motion (DCM) help in balance control?"}),"\n",(0,o.jsx)(e.li,{children:"What are the main phases of a walking cycle and how do they affect balance?"}),"\n",(0,o.jsx)(e.li,{children:"How does the inverted pendulum model apply to humanoid balance control?"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter covered the fundamental concepts of bipedal locomotion and balance control for humanoid robots. We explored ZMP-based walking pattern generation, footstep planning, balance control mechanisms, and stability algorithms including Capture Point and DCM theory. The chapter provided practical implementations for generating stable walking patterns and maintaining balance during locomotion."}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"In the next chapter, we'll explore manipulation and grasping techniques for humanoid robots, covering dexterous manipulation strategies, grasp planning, and human-robot interaction design."})]})}function c(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(_,{...t})}):_(t)}},8453(t,e,n){n.d(e,{R:()=>s,x:()=>a});var o=n(6540);const i={},r=o.createContext(i);function s(t){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),o.createElement(r.Provider,{value:e},t.children)}}}]);