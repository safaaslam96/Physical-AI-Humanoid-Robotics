---
title: "باب 3: ROS 2 آرکیٹیکچر اور بنیادی تصورات"
sidebar_label: "باب 3: ROS 2 آرکیٹیکچر"
---

# باب 3: ROS 2 آرکیٹیکچر اور بنیادی تصورات

## سیکھنے کے اہداف
- ROS 2 کی بنیادی تعمیر کو سمجھنا
- نوڈز، ٹاپکس، سروسز، اور ایکشنز کے تصورات میں مہارت حاصل کرنا
- ROS 2 ایکو سسٹم اور اس کے اجزاء کا جائزہ
- روبوٹک کنٹرول سسٹمز میں ROS 2 کے اصولوں کا اطلاق

## تعارف

روبوٹ آپریٹنگ سسٹم 2 (ROS 2) جدید روبوٹک پلیٹ فارم کا "نروس سسٹم" کا کام کرتا ہے، مڈل ویئر انفراسٹرکچر فراہم کرتا ہے جو جٹیل روبوٹک سسٹمز کو ایک مربوط ہول کے طور پر کام کرنے کے قابل بناتا ہے۔ اس کے جانشین کے برعکس، ROS 2 حقیقی دنیا کی تنصیب کے چیلنجز کو بہتر سیکورٹی، حقیقی وقت کی صلاحیتوں، اور پروڈکشن-تیاری کے ساتھ حل کرتا ہے۔ یہ باب جٹیل روبوٹک اطلاقات تیار کرنے کے لیے ROS 2 تعمیر کی بنیادی سمجھ قائم کرتا ہے۔

## ROS 1 سے ROS 2 کی ترقی

### ROS 2 کی حوصلہ افزائی

ROS 2 کو ROS 1 کی اہم کمیوں کو حل کرنے کے لیے تیار کیا گیا:

- **سیکورٹی**: ROS 1 کو تصدیق اور انکرپشن کی کمی تھی
- **حقیقی وقت کی معاونت**: وقت کے اہم اطلاقات کے لیے ناکافی
- **متعدد روبوٹ سسٹمز**: متعدد روبوٹس کو مربوط کرنا مشکل تھا
- **پروڈکشن تنصیب**: کمرشل اطلاقات کے لیے ڈیزائن نہیں کیا گیا
- **سروس کی معیار (QoS)**: پیغام کی ترسیل کے لیے کوئی ضمانت نہیں

### ROS 2 میں کلیدی بہتریاں

1. **DDS انضمام**: مضبوط مواصلات کے لیے ڈیٹا ڈسٹری بیوشن سروس (DDS)
2. **سیکورٹی فریم ورک**: تصدیق، انکرپشن، اور رسائی کنٹرول
3. **حقیقی وقت کی صلاحیتیں**: حقیقی وقت کے سسٹمز اور ڈیٹرمنزم کی معاونت
4. **متعدد پلیٹ فارم کی معاونت**: ونڈوز، میک او ایس، لینکس، اور ایمبیڈڈ سسٹمز
5. **پیکج مینجمنٹ**: بہتر بِلڈ سسٹم اور انحصار کا نظم

## ROS 2 آرکیٹیکچر کا جائزہ

### کلائنٹ لائبریری آرکیٹیکچر

ROS 2 ایک پرت دار تعمیر کا استعمال کرتا ہے:

```
ایپلیکیشن لیئر (یوزر کوڈ)
├── rclcpp (C++)
├── rclpy (Python)
├── rcl (C)
└── DDS امplementیشن
```

یہ تعمیر ایک جیسے ROS 2 اطلاقات کو مختلف DDS امplementations پر چلنے کی اجازت دیتا ہے جبکہ مسلسل APIs برقرار رکھتا ہے۔

### مواصلاتی نمونے

ROS 2 متعدد مواصلاتی نمونوں کی معاونت کرتا ہے:

1. **پبلش/سبسکرائب (ٹاپکس)**: ایک سے کئی، غیر ہم وقت مواصلات
2. **ریکویسٹ/ریسپانس (سروسز)**: ہم وقت کلائنٹ-سرور مواصلات
3. **ایکشن-مبنی مواصلات**: فیڈ بیک کے ساتھ غیر ہم وقت ریکویسٹ/ریسپانس
4. **پیرامیٹرز**: نوڈز کے درمیان کنفیگریشن مینجمنٹ

## بنیادی تصورات

### نوڈز

ایک نوڈ ROS 2 میں کمپیوٹیشن کی بنیادی اکائی ہے:

**تعریف**: ایک عمل جو کمپیوٹیشن کرتا ہے اور دیگر نوڈز کے ساتھ مواصلات کرتا ہے۔

**اہم خصوصیات**:
- ہر نوڈ آزادانہ طور پر چلتا ہے
- نوڈز ٹاپکس، سروسز، اور ایکشنز کے ذریعے مواصلات کرتے ہیں
- متعدد نوڈز ایک ہی مشین یا تقسیم شدہ سسٹمز پر چل سکتے ہیں
- نوڈز ROS 2 ایگزیکیوشن ماحول کے ذریعے منظم کیے جاتے ہیں

**نوڈ لائف سائیکل**:
1. **غیر ترتیب شدہ**: نوڈ موجود ہے لیکن ابھی ترتیب نہیں دیا گیا
2. **غیر فعال**: ترتیب دیا گیا لیکن فعال نہیں ہے
3. **فعال**: چل رہا ہے اور ڈیٹا پروسیس کر رہا ہے
4. **حتمی**: نوڈ بند ہو رہا ہے

**مثال نوڈ سٹرکچر**:
```python
import rclpy
from rclpy.node import Node

class MyRobotNode(Node):
    def __init__(self):
        super().__init__('robot_controller')
        # publishers، subscribers، services، وغیرہ کو شروع کریں
```

### ٹاپکس اور میسج پاسنگ

**ٹاپکس** غیر ہم وقت، ایک سے کئی مواصلات کو فعال کرتے ہیں:

**خصوصیات**:
- ڈیٹا نامزد ٹاپکس پر پبلش کیا جاتا ہے
- متعدد سبسکرائبرز ایک ہی ڈیٹا وصول کر سکتے ہیں
- پبلشرز اور سبسکرائبرز وقت کے لحاظ سے الگ الگ ہیں
- پبلشرز اور سبسکرائبرز کے درمیان کوئی براہ راست کنکشن نہیں ہے

**میسج اقسام**:
- `msg` ڈائریکٹری میں `.msg` فائلز کا استعمال کرکے تعریف کیا گیا
- بِلڈ کے دوران زبان کے مطابق کوڈ میں تبدیل کیا گیا
- مضبوط طور پر ٹائپ شدہ اور کمپائل ٹائم پر تصدیق شدہ

**سروس کی معیار (QoS)**:
ROS 2 مواصلاتی رویے کو کنٹرول کرنے کے لیے QoS پروفائلز فراہم کرتا ہے:

- **قابل اعتماد**: بہتر کوشش بمقابلہ قابل اعتماد ترسیل
- **دوام**: متزلزل بمقابلہ عارضی مقامی
- **تاریخ**: آخری N پیغامات رکھیں بمقابلہ سب کچھ رکھیں
- **آخری تاریخ**: اشاعت کے درمیان زیادہ سے زیادہ وقت
- **لائیو لیس**: یہ پتہ لگانے کا طریقہ کہ پبلشر زندہ ہے یا نہیں

### سروسز

**سروسز** ہم وقت ریکویسٹ/ریسپانس مواصلات فراہم کرتی ہیں:

**خصوصیات**:
- ایک سے ایک مواصلاتی نمونہ
- ریسپانس سے پہلے ریکویسٹ کو پروسیس کرنا لازمی ہے
- ریسپانس موصول ہونے تک بلاکنگ کال
- حالت کے سوالات اور کنفیگریشن کے لیے مناسب

**سروس اقسام**:
- ریکویسٹ/ریسپانس سٹرکچر کے ساتھ `.srv` فائلز کا استعمال کرکے تعریف کیا گیا
- بِلڈ کے دوران زبان کے مطابق کوڈ میں تبدیل کیا گیا
- جٹیل ڈیٹا سٹرکچرز کی معاونت

### ایکشنز

**ایکشنز** فیڈ بیک کے ساتھ غیر ہم وقت ریکویسٹ/ریسپانس فراہم کرتے ہیں:

**خصوصیات**:
- حالت کی اپ ڈیٹس کے ساتھ طویل مدتی کام
- انجام دہی کے دوران فیڈ بیک پیغامات
- گول پریمپشن کی صلاحیت
- نیویگیشن، مینیپولیشن، وغیرہ کے لیے مناسب

**ایکشن اجزاء**:
- **گول**: ایکشن انجام دہی کے لیے درخواست
- **فیڈ بیک**: انجام دہی کے دوران حالت کی اپ ڈیٹس
- **نتیجہ**: ایکشن کا حتمی نتیجہ

## ROS 2 ایکو سسٹم کو سمجھنا

### بنیادی اجزاء

1. **ros2cli**: کمانڈ لائن انٹرفیس ٹولز
   - `ros2 run`: نوڈز چلانا
   - `ros2 topic`: ٹاپکس کی تحقیق اور پبلشنگ
   - `ros2 service`: سروس کی تحقیق اور کالنگ
   - `ros2 node`: نوڈ کی تحقیق اور مینجمنٹ
   - `ros2 param`: پیرامیٹر مینجمنٹ

2. **rcl**: روبوٹ کلائنٹ لائبریری امپلیمنٹیشنز
   - C++ کے لیے rclcpp
   - Python کے لیے rclpy
   - مائیکرو کنٹرولرز کے لیے rclc
   - Java کے لیے rcljava

3. **DDS امپلیمنٹیشنز**:
   - Fast DDS (زیادہ تر تقسیم میں ڈیفالٹ)
   - Cyclone DDS
   - RTI Connext DDS
   - Eclipse Zenoh

### بِلڈ سسٹم: colcon

ROS 2 بِلڈ سسٹم کے طور پر colcon کا استعمال کرتا ہے:

**خصوصیات**:
- پیکجز کی متوازی تعمیر
- متعدد پیکج اقسام کی معاونت
- لچکدار ورک سپیس مینجمنٹ
- CMake، ament، اور دیگر بِلڈ سسٹمز کے ساتھ انضمام

**ورک سپیس سٹرکچر**:
```
ورک سپیس/
├── src/          # سورس پیکجز
├── build/        # بِلڈ آرٹیفیکٹس
├── install/      # انسٹالیشن ڈائریکٹری
└── log/          # بِلڈ لاگز
```

### پیکج مینجمنٹ

ROS 2 پیکجز بنیادی سافٹ ویئر ماڈیولز پر مشتمل ہیں:

**پیکج سٹرکچر**:
```
my_robot_package/
├── CMakeLists.txt
├── package.xml
├── src/
├── include/
├── launch/
├── config/
├── test/
└── scripts/
```

## عملی امپلیمنٹیشن: ROS 2 نوڈ تیار کرنا

### ROS 2 پیکج سیٹ اپ کرنا

```bash
# ایک نیا پیکج بنائیں
ros2 pkg create --build-type ament_python my_robot_controller
```

### ایک پبلشر نوڈ بنانا

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class RobotStatusPublisher(Node):
    def __init__(self):
        super().__init__('robot_status_publisher')
        self.publisher = self.create_publisher(String, 'robot_status', 10)
        timer_period = 0.5  # سیکنڈ
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Robot status: operational {self.i}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    robot_status_publisher = RobotStatusPublisher()
    rclpy.spin(robot_status_publisher)
    robot_status_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### ایک سبسکرائبر نوڈ بنانا

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class RobotStatusSubscriber(Node):
    def __init__(self):
        super().__init__('robot_status_subscriber')
        self.subscription = self.create_subscription(
            String,
            'robot_status',
            self.listener_callback,
            10)
        self.subscription  # غیر استعمال شدہ متغیر کی وارننگ کو روکیں

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    robot_status_subscriber = RobotStatusSubscriber()
    rclpy.spin(robot_status_subscriber)
    robot_status_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## فزیکل ای آئی کے سیاق میں ROS 2

### فزیکل ای آئی سسٹمز کے لیے مڈل ویئر

ROS 2 فزیکل ای آئی سسٹمز کے لیے مواصلاتی پشت کا کام کرتا ہے:

**سینسر انضمام**:
- حقیقی وقت کا سینسر ڈیٹا تقسیم
- متعدد سینسرز کے درمیان ہم وقت سازی
- وقت کے اہم ڈیٹا کے لیے سروس کی معیار

**کنٹرول سسٹم انضمام**:
- تقسیم شدہ کنٹرول آرکیٹیکچرز
- حقیقی وقت کمانڈ انجام دہی
- حفاظتی سسٹم انضمام

**ای آئی سسٹم انضمام**:
- ادراک اور منصوبہ بندی کے درمیان ڈیٹا فلو
- جسمانی سسٹمز میں کمانڈ انجام دہی
- سیکھنے اور مطابقت کی فیڈ بیک لوپس

### فزیکل ای آئی اطلاقات کے لیے بہترین طریقے

1. **حقیقی وقت کے امور**:
   - وقت کے اہم ڈیٹا کے لیے مناسب QoS ترتیبات کا استعمال
   - مواصلاتی اوور ہیڈ کو کم کریں
   - حفاظت کے لیے مخصوص مواصلاتی چینلز کا تصور کریں

2. **حفاظتی انضمام**:
   - حفاظتی حالت کی نگرانی نافذ کریں
   - حفاظتی کنفیگریشن کے لیے پیرامیٹر سرورز کا استعمال
   - حفاظتی مواصلاتی نمونے ڈیزائن کریں

3. **کارکردگی کی بہتری**:
   - مؤثر میسج سیریلائزیشن
   - مناسب میسج فریکوئینسی
   - مسلسل کام کے لیے میموری مینجمنٹ

## نالج چیک

1. ROS 2 میں ٹاپکس، سروسز، اور ایکشنز کے درمیان فرق کی وضاحت کریں۔
2. سروس کی معیار (QoS) کیا ہے اور یہ ROS 2 میں کیوں اہم ہے؟
3. ROS 2 میں نوڈ لائف سائیکل کی وضاحت کریں اور اس کی اہمیت بیان کریں۔

## ہاتھوں سے مشق

1. ایک پبلشر اور سبسکرائبر کے ساتھ ایک سادہ ROS 2 پیکج بنائیں
2. ایک سروس نافذ کریں جو روبوٹ کی حالت کی معلومات فراہم کرے
3. مختلف قسم کے پیغامات کے لیے مناسب QoS ترتیبات تشکیل دیں
4. نوڈز کے درمیان مواصلات کو ٹیسٹ کریں اور رویے کا مشاہدہ کریں

## خلاصہ

ROS 2 آرکیٹیکچر جٹیل فزیکل ای آئی سسٹمز کے لیے مضبوط مڈل ویئر فاؤنڈیشن فراہم کرتا ہے۔ نوڈز، ٹاپکس، سروسز، اور ایکشنز کو سمجھنا جسمانی ماحول میں مؤثر طریقے سے کام کرنے والی تقسیم شدہ روبوٹک اطلاقات تیار کرنے کے لیے اہم ہے۔ تعمیر کا توجہ سیکورٹی، حقیقی وقت کی صلاحیتوں، اور پروڈکشن تیاری پر ہونا فزیکل ای آئی اطلاقات کے لیے اسے بہترین بناتا ہے۔

## اگلے اقدامات

اگلے باب میں، ہم Python کے ساتھ ROS 2 پیکجز تیار کرنا تلاش کریں گے، یہاں متعارف کرائے گئے تصورات کی عملی امپلیمنٹیشن میں گہرائی میں جاتے ہوئے۔