---
title: "ہفتہ 3-5: ROS 2 کی بنیادیں"
sidebar_label: "ہفتہ 3-5: ROS 2 کی بنیادیں"
---

# ہفتہ 3-5: ROS 2 کی بنیادیں

## ماڈیول 1: روبوٹ کا نروس سسٹم (ROS 2)

### مرکز: روبوٹ کنٹرول کے لیے میڈل ویئر

### سیکھنے کے اہداف
- ROS 2 آرکیٹیکچر اور بنیادی تصورات کو سمجھنا
- ROS 2 نوڈز، ٹاپکس، اور سروسز کو لاگو کرنا
- Python کے ساتھ ROS 2 پیکجز تیار کرنا
- لانچ فائلز اور پیرامیٹر مینجمنٹ کو ترتیب دینا
- rclpy کا استعمال کرتے ہوئے Python ایجنٹس کو ROS کنٹرولرز سے جوڑنا
- انسان نما روبوٹس کے لیے URDF (یونیفائلڈ روبوٹ ڈسکرپشن فارمیٹ) تیار کرنا

## ROS 2 آرکیٹیکچر اور بنیادی تصورات

### ROS 2 کیا ہے؟

ROS 2 (روبوٹ آپریٹنگ سسٹم 2) روبوٹ سافٹ ویئر لکھنے کے لیے ایک لچک دار فریم ورک ہے۔ یہ ایک ایسے ٹولز، لائبریریز، اور کنونشن کا مجموعہ ہے جو کئی مختلف روبوٹ پلیٹ فارمز پر جٹیل اور مضبوط روبوٹ برتاؤ کو آسان بنانے کے لیے کام کرتا ہے۔

### ROS 1 سے ROS 2 کی تبدیلی

#### ROS 2 کے لیے حوصلہ

ROS 2 کو ROS 1 کی اہم کمیوں کو پورا کرنے کے لیے تیار کیا گیا:

- **سیکورٹی**: ROS 1 میں تصدیق اور انکرپشن نہیں تھا
- **ریل ٹائم سپورٹ**: وقت کے اہم ایپلی کیشنز کے لیے ناکافی
- **میولٹی روبوٹ سسٹم**: متعدد روبوٹس کو مربوط کرنا مشکل تھا
- **پروڈکشن ڈیپلومنٹ**: تجارتی ایپلی کیشنز کے لیے ڈیزائن نہیں کیا گیا
- **کوالٹی آف سروس (QoS)**: پیغام کی ترسیل کے لیے کوئی گارنٹی نہیں

#### ROS 2 میں کلیدی بہتریاں

1. **DDS انضمام**: ڈیٹا ڈسٹری بیوشن سروس (DDS) مضبوط مواصلات کے لیے
2. **سیکورٹی فریم ورک**: تصدیق، انکرپشن، اور رسائی کنٹرول
3. **ریل ٹائم صلاحیتیں**: ریل ٹائم سسٹم اور ڈیٹرمنزم کے لیے سپورٹ
4. **میولٹی پلیٹ فارم سپورٹ**: ونڈوز، میک او ایس، لینکس، اور ایمبیڈڈ سسٹم
5. **پیکج مینجمنٹ**: بہتر بِلڈ سسٹم اور انحصار مینجمنٹ

## بنیادی تصورات

### نوڈز

ایک نوڈ روبوٹ میں کمپیوٹیشن کا بنیادی یونٹ ہے:

**تعریف**: ایک عمل جو کمپیوٹیشن کرتا ہے اور دوسرے نوڈز کے ساتھ رابطہ کرتا ہے۔

**اہم خصوصیات**:
- ہر نوڈ آزادانہ طور پر چلتا ہے
- نوڈز ٹاپکس، سروسز، اور ایکشنز کے ذریعے رابطہ کرتے ہیں
- متعدد نوڈز ایک ہی مشین پر یا تقسیم شدہ سسٹم میں چل سکتے ہیں
- نوڈز ROS 2 ایگزیکیوشن ماحول کے ذریعے منظم کیے جاتے ہیں

### ٹاپکس اور پیغام کا تبادلہ

**ٹاپکس** غیر ہم وقت، ایک سے کئی کی مواصلات کو فعال کرتے ہیں:

**خصوصیات**:
- ڈیٹا نامزد ٹاپکس پر پبلش کیا جاتا ہے
- متعدد سبسکرائبرز ایک ہی ڈیٹا حاصل کر سکتے ہیں
- پبلشر اور سبسکرائبرز وقت کے لحاظ سے الگ ہوتے ہیں
- پبلشر اور سبسکرائبرز کے درمیان کوئی براہ راست رابطہ نہیں ہے

### سروسز

**سروسز** ہم وقت، درخواست/جواب کی مواصلات فراہم کرتے ہیں:

**خصوصیات**:
- ایک سے ایک کی مواصلات کا نمونہ
- درخواست کو جواب سے پہلے عمل کرنا ضروری ہے
- جواب ملنے تک بلاکنگ کال
- حالت کے سوالات اور کنفیگریشن کے لیے مناسب

### ایکشنز

**ایکشنز** غیر ہم وقت، درخواست/جواب کے ساتھ فیڈ بیک کی مواصلات فراہم کرتے ہیں:

**خصوصیات**:
- سرگرمی کے دوران رپورٹ کے ساتھ طویل چلنے والے کام
- سرگرمی کے دوران فیڈ بیک پیغامات
- گول پریمپشن کی صلاحیت
- نیوی گیشن، مینوپولیشن وغیرہ کے لیے مناسب

## ROS 2 ایکو سسٹم کو سمجھنا

### کور اجزاء

1. **ros2cli**: کمانڈ لائن انٹرفیس ٹولز
   - `ros2 run`: نوڈز چلانا
   - `ros2 topic`: ٹاپکس کی تنصیب اور پبلش کرنا
   - `ros2 service`: سروس کی تنصیب اور کال کرنا
   - `ros2 node`: نوڈ کی تنصیب اور مینجمنٹ
   - `ros2 param`: پیرامیٹر مینجمنٹ

2. **rcl**: روبوٹ کلائنٹ لائبریری ایپلی کیشنز
   - rclcpp for C++
   - rclpy for Python
   - rclc for مائیکرو کنٹرولرز
   - rcljava for جاوا

## عملی اطلاق: ROS 2 نوڈ تیار کرنا

### ROS 2 پیکج سیٹ اپ کرنا

```bash
# ایک نیا پیکج بنائیں
ros2 pkg create --build-type ament_python my_robot_controller
```

### ایک پبلشر نوڈ بنانا

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class RobotStatusPublisher(Node):
    def __init__(self):
        super().__init__('robot_status_publisher')
        self.publisher = self.create_publisher(String, 'robot_status', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Robot status: operational {self.i}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    robot_status_publisher = RobotStatusPublisher()
    rclpy.spin(robot_status_publisher)
    robot_status_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## فزیکل ای کے تناظر میں ROS 2

### فزیکل ای سسٹم کے لیے میڈل ویئر

ROS 2 فزیکل ای سسٹم کے لیے رابطے کا پُل کے طور پر کام کرتا ہے:

**سینسر انضمام**:
- ریل ٹائم سینسر ڈیٹا کی تقسیم
- متعدد سینسرز کے درمیان ہم وقت سازی
- وقت کے اہم ڈیٹا کے لیے کوالٹی آف سروس

**کنٹرول سسٹم انضمام**:
- تقسیم شدہ کنٹرول آرکیٹیکچر
- ریل ٹائم کمانڈ ایگزیکیوشن
- سیفٹی سسٹم انضمام

**AI سسٹم انضمام**:
- تاثر اور منصوبہ بندی کے درمیان ڈیٹا فلو
- جسمانی سسٹم میں کمانڈ ایگزیکیوشن
- سیکھنے اور مطابقت کے فیڈ بیک لوپس

## جائزہ

ROS 2 آرکیٹیکچر جامع فزیکل ای سسٹم کے لیے مضبوط میڈل ویئر بنیاد فراہم کرتا ہے۔ نوڈز، ٹاپکس، سروسز، اور ایکشنز کو سمجھنا جسمانی ماحول میں مؤثر طریقے سے کام کرنے والے تقسیم شدہ روبوٹک ایپلی کیشنز تیار کرنے کے لیے ضروری ہے۔ سیکورٹی، ریل ٹائم صلاحیتوں، اور پروڈکشن تیاری پر اس کا زور فزیکل ای ایپلی کیشنز کے لیے اسے بہترین بنا دیتا ہے۔